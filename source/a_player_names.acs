// VARIABLES
int ALL_VARS[20][100][4];

#define VIEW_MATRIX_4x4 0 //float array[4][4]
#define VECTOR_A_3x1 1 //float array[4]
#define VECTOR_B_3x1 2 //float array[4]
#define VECTOR_C_3x1 3 //float array[4]
#define PREV_FOV_RATIO 4 //float
#define RESULT_SCREEN_X 5 //float
#define RESULT_SCREEN_Y 6 //float
#define PROJECTION_BC_H 7 //float
#define PROJECTION_BC_V 8 //float
#define SPAWN_ROOM_1 9 //bitmap
#define SPAWN_ROOM_2 10 //bitmap

#define RESULT_DISTANCE 11 //int
#define TRACKING_TYPE 12 //int 0 - disabled, 1 - 50 units, 2 - 100 units, 3 - any distance
#define SPOTTED_ACTOR 13 // int array[100]
#define SPOTTED_ACTOR_TIME 14 // int array[100]
#define SPOT_PROCESS_DIRTY 15 // bool
#define SPOTTED_ACTOR_CLIENT 16// int array[100]

// SCRIPTS
#define S_IS_IN_SPAWNROOM 1010
#define S_CROSS 1011
#define S_NORMALIZE 1012
#define S_PROJECTION 1013
#define S_SWITCH_TRACKING_TYPE 1014
#define S_SET_SPAWN_PAGE_1 1015
#define S_SET_SPAWN_PAGE_2 1016
#define S_SPWAN_ROOM_CHECK 1017
#define S_SPOT_ACTOR 1018
#define S_SPOT_ACTOR_CLIENT 1019
#define S_DRAW_NAMES 1020
#define S_SPOT_ACTOR_PUFF 1021
#define S_SPOT_TIMEOUT_CHECK 1022
#define S_UNSPOT_ACTOR_CLIENT 1023
#define S_DRAW_NAMES_PLAYERS 1024
#define S_DRAW_NAMES_ACTORS 1025

//CONST
#define SPOT_DURATION_TIC 350 // int  10 seconds

function str GetActorName(int tid)
{
	str actorName = GetActorClass(tid);
	if(actorName == "TimedC4ArmedBlue" || actorName == "TimedC4Armed")
	{
		return strparam(s:"C4");
	}
	
	if(actorName == "NuclearStrikeBeaconArmed")
	{
		return strparam(s:"Nuke beacon");
	}
	if(actorName == "IonCannonBeaconArmed")
	{
		return strparam(s:"Ion beacon");
	}
	
	if(actorName == "Utility_GunTurretRed" || actorName == "Utility_GunTurretBlue")
	{
		return strparam(s:"Gun Turret");
	}
	
	if(actorName == "Utility_ChemTurretRed" || actorName == "Utility_ChemTurretBlue")
	{
		return strparam(s:"Chem Turret");
	}
	
	if(actorName == "Utility_FlameTurretRed" || actorName == "Utility_FlameTurretBlue")
	{
		return strparam(s:"Flame Turret");
	}
	
	if(actorName == "Utility_PrecisionTurretRed" || actorName == "Utility_PrecisionTurretBlue")
	{
		return strparam(s:"Precision Turret");
	}
	
	if(actorName == "Utility_ArtilleryTurretRed" || actorName == "Utility_ArtilleryTurretBlue")
	{
		return strparam(s:"Artillery Turret");
	}
	
	if(actorName == "Utility_RepairGunTurretRed" || actorName == "Utility_RepairGunTurretBlue")
	{
		return strparam(s:"Repair Turret");
	}
	
	if(actorName == "Utility_KlaxonRed" || actorName == "Utility_KlaxonBlue")
	{
		return strparam(s:"Klaxon Turret");
	}
	
	if(actorName == "Utility_MiniRavenRed" || actorName == "Utility_MiniRavenBlue")
	{
		return strparam(s:"Mini Raven");
	}
	
	if(actorName == "TeleporterNodeRed" || actorName == "TeleporterNodeBlue")
	{
		return strparam(s:"Teleport");
	}
	
	return strparam(s:"None");
}

function str GetActorTeam(int tid)
{
	str actorName = GetActorClass(tid);
	
	if(actorName == "TimedC4ArmedBlue" ||
		actorName == "IonCannonBeaconArmed" ||
		actorName == "Utility_GunTurretBlue" ||
		actorName == "Utility_ChemTurretBlue" ||
		actorName == "Utility_FlameTurretBlue" ||
		actorName == "Utility_PrecisionTurretBlue" ||
		actorName == "Utility_ArtilleryTurretBlue" ||
		actorName == "Utility_RepairGunTurretBlue" ||
		actorName == "Utility_KlaxonBlue" ||
		actorName == "Utility_MiniRavenBlue" ||
		actorName == "TeleporterNodeBlue")
	{
		return 0;
	}
	else if(actorName == "TimedC4Armed" ||
		actorName == "NuclearStrikeBeaconArmed" ||
		actorName == "Utility_GunTurretRed" ||
		actorName == "Utility_ChemTurretRed" ||
		actorName == "Utility_FlameTurretRed" ||
		actorName == "Utility_PrecisionTurretRed" ||
		actorName == "Utility_ArtilleryTurretRed" ||
		actorName == "Utility_RepairGunTurretRed" ||
		actorName == "Utility_KlaxonRed" ||
		actorName == "Utility_MiniRavenRed" ||
		actorName == "TeleporterNodeRed")
	{
		return 1;
	}
	return -1;
}



SCRIPT S_SWITCH_TRACKING_TYPE (void) net CLIENTSIDE
{	
	ALL_VARS[TRACKING_TYPE][0][0]++;
	if(ALL_VARS[TRACKING_TYPE][0][0] > 3)
	{
		ALL_VARS[TRACKING_TYPE][0][0] = 0;
	}
	
	SetFont("BIGFONT");
	switch(ALL_VARS[TRACKING_TYPE][0][0])
	{
		case 0:
		HudMessage(s:"Player names are Off"; HUDMSG_PLAIN, 9400, CR_WHITE, 0.5, 0.2, 2.0);
		break;
		
		case 1:
		HudMessage(s:"Player names are On for distance 50"; HUDMSG_PLAIN, 9400, CR_WHITE, 0.5, 0.2, 3.0);
		break;
		
		case 2:
		HudMessage(s:"Player names are On for distance 100"; HUDMSG_PLAIN, 9400, CR_WHITE, 0.5, 0.2, 3.0);
		break;
		
		case 3:
		HudMessage(s:"Player names are On for any distance"; HUDMSG_PLAIN, 9400, CR_WHITE, 0.5, 0.2, 3.0);
		break;
		
		default:
		HudMessage(s:"Track type is not supported: ", i:ALL_VARS[TRACKING_TYPE][0][0]; HUDMSG_PLAIN, 9400, CR_WHITE, 0.5, 0.2, 3.0);
		break;
	}
		
	
	str cvar = strparam (s:"toggle_names");
	SetCVar(cvar, ALL_VARS[TRACKING_TYPE][0][0]);
}

SCRIPT S_SET_SPAWN_PAGE_1(int spawnRoomBitMap) CLIENTSIDE
{
	ALL_VARS[SPAWN_ROOM_1][0][0] = spawnRoomBitMap;
}
SCRIPT S_SET_SPAWN_PAGE_2(int spawnRoomBitMap) CLIENTSIDE
{
	ALL_VARS[SPAWN_ROOM_2][0][0] = spawnRoomBitMap;
}

SCRIPT S_UNSPOT_ACTOR_CLIENT(int actorIndex) CLIENTSIDE
{
	Print(s:"========== ", s:" Client-side unspot tid: ", i:ALL_VARS[SPOTTED_ACTOR_CLIENT][actorIndex][0]);
	ALL_VARS[SPOTTED_ACTOR_CLIENT][actorIndex][0] = 0;
}

SCRIPT S_SPOT_ACTOR_CLIENT(int actorIndex, int sp_tid) CLIENTSIDE
{
	Print(s:"========== ", s:" Client-side spot tid: ", i:sp_tid);
	ALL_VARS[SPOTTED_ACTOR_CLIENT][actorIndex][0] = sp_tid;
}

SCRIPT S_SPOT_ACTOR (void) NET //trys to spot player at sight
{
	int originalTid = ActivatorTID();
	int originalPlayerNumber = originalTid - 3800;
	int pTeam = GetPlayerTeam(originalPlayerNumber);
	
	int capAngle = GetActorAngle(originalTid);
	int camPitch = GetActorPitch(originalTid);
	str playerName = strparam (n:originalPlayerNumber + 1);
	Log(s:"========== ", s:playerName, s:" tried spot");
	
	LineAttack (0, capAngle, camPitch, 0, "HitscanPuff", "None", 2048.0);
}


SCRIPT S_SPOT_TIMEOUT_CHECK OPEN
{
	while(true)
	{
		delay(1);
		
		for(int i = 0; i < 100; i++)
		{
			int TID = ALL_VARS[SPOTTED_ACTOR][i][0];
			if(TID == 0)
			{
				continue;
			}
			
			bool needToUnspot = false;
			bool isPlayer = TID >= 3800 && TID < 3800 + MAXPLAYERS;
			
			if(isPlayer)
			{
				int playerN = TID - 3800;
				int inGame = PlayerInGame(playerN);
				if(!inGame && ALL_VARS[SPOTTED_ACTOR][i][0] != 0)
				{
					needToUnspot = true;
					Log(s:"========== ", i:TID, s:" player need unspot by exit the game!");
					
				}
			}
			else // turret, c4, nuke/ion
			{
				bool isUsed = IsTIDUsed(TID);
				if(!isUsed && ALL_VARS[SPOTTED_ACTOR][i][0] != 0)
				{
					needToUnspot = true;	
					Log(s:"========== ", i:TID, s:" item need to unspot by destruction");
				}
			}
			
			//actor is present now check the timeout
			if(!needToUnspot)
			{
				int spotTime = ALL_VARS[SPOTTED_ACTOR_TIME][i][0];
				bool timeout = (timer() - spotTime) > SPOT_DURATION_TIC;
				needToUnspot = timeout && ALL_VARS[SPOTTED_ACTOR][i][0] != 0;
				
				if(needToUnspot)
				{
					Log(s:"========== ", i:TID, s:" need unspot by timeout");
				}
			}
			
			
			if(needToUnspot)
			{
				bool needToBreakOuter = false;
				
				for(int playerIndex = 0; playerIndex < MAXPLAYERS; playerIndex++)
				{
					delay(1);
					
					if(ALL_VARS[SPOT_PROCESS_DIRTY][0][0])
					{
						ALL_VARS[SPOT_PROCESS_DIRTY][0][0] = false;
						needToBreakOuter = true;
						break;
					}
					ExecuteClientScript(S_UNSPOT_ACTOR_CLIENT, playerIndex, i);
				}	
				
				
				if(needToBreakOuter)
				{
					break;
				}
				ALL_VARS[SPOTTED_ACTOR][i][0] = 0;
			}
		}
	}
}

SCRIPT S_SPOT_ACTOR_PUFF (void)
{
	int playerTID = GetActorProperty(0, APROP_TargetTID);
	int targetTID = GetActorProperty(0, APROP_TRACERTID);
	
	if(targetTID == 0)
	{
		terminate;
	}
	
	int playerIndex = playerTID - 3800;
	int pTeam = GetPlayerTeam(playerIndex);
	
	str playerName = strparam(n:playerIndex + 1);
	
	str team = strparam(s:"red");
	if(pTeam == 0)
	{
		team = strparam(s:"blue");
	}
	str logT = strparam(s:"========== server: player", s:playerName, s:" of team ", s:team);
	
	int targetTeam = -1;
	
	bool isTargetPlayer = targetTID >= 3800 && targetTID < 3800 + MAXPLAYERS;
	if(isTargetPlayer)
	{
		int taregtIndex = targetTID - 3800;	
		targetTeam = GetPlayerTeam(taregtIndex);
		if(targetTeam == -1)
		{
			terminate;
		}
	
		str tName = strparam(n:taregtIndex + 1);
		
		str tTeam = strparam(s:"red");
		if(targetTeam == 0)
		{
			tTeam = strparam(s:"blue");
		}
		logT = strparam(s:logT, s:" spot player ", s:tName, s:" of team ", s:tTeam);
	}
	else
	{
		targetTeam = GetActorTeam(targetTID);
		str actorName = GetActorName(targetTID);
		if(targetTeam == -1)
		{
			terminate;
		}
		
		str aTeam = strparam(s:"red");
		if(targetTeam == 0)
		{
			aTeam = strparam(s:"blue");
		}
		logT = strparam(s:logT, s:" spot actor ", s:actorName, s:" of team ", s:aTeam);
	}
	
	if(pTeam == targetTeam)
	{
		terminate;
	}
	
	printBold(s:logT);
	
	//check if already spottedTID
	bool alreadySpotted = false;
	for(int i = 0; i < 100; i++)
	{
		if(ALL_VARS[SPOTTED_ACTOR][i][0] == targetTID)
		{
			ALL_VARS[SPOT_PROCESS_DIRTY][0][0] = true;
			ALL_VARS[SPOTTED_ACTOR_TIME][i][0] = timer();
			alreadySpotted = true;
			break;
		}
	}
	
	if(alreadySpotted)
	{
		terminate;
	}
	
	//spot
	for(i = 0; i < 100; i++)
	{
		if(ALL_VARS[SPOTTED_ACTOR][i][0] == 0)
		{
			ALL_VARS[SPOT_PROCESS_DIRTY][0][0] = true;
			ALL_VARS[SPOTTED_ACTOR][i][0] = targetTID;
			ALL_VARS[SPOTTED_ACTOR_TIME][i][0] = timer();
			
			for(playerIndex = 0; playerIndex < MAXPLAYERS; playerIndex++)
			{
				delay(1);
				ExecuteClientScript(S_SPOT_ACTOR_CLIENT, playerIndex, i, targetTID);
			}
			break;
		}
	}
}

//tracks whether players are in spawnroom or not
SCRIPT S_SPWAN_ROOM_CHECK OPEN 
{
	//there are 32 bits in integer. each bit is a flag for whether player is in spawn room for player numbers from 0 to 31
	// one integer value covers 32 players
	int pageSize = 32; 
	
	int inSpawnRoomPage_1 = 0; //first 32 players
	int inSpawnRoomPage_2 = 0; //last 32 players
	
	while (true)
	{
		delay(1);
		
		for(int page = 0; page < 2; page++)
		{
			int pageStart = page * pageSize; 
			int pageEnd = (page + 1) * pageSize;
			
			int newBitMap = 0;
			for(int i = pageStart; i < pageEnd; i++) // i is a player index and also a bit position
			{
				int tid = i + 3800;
				int inSpawnRoom = CheckActorInventory(tid, "IsInSpawnRoom");
				if(inSpawnRoom)
				{
					newBitMap |= 1 << (i - pageStart);
				}
				else
				{
					newBitMap &= ~(1 << (i - pageStart));
				}
			}
			
			if(page == 0)
			{
				if(newBitMap != inSpawnRoomPage_1)
				{
					inSpawnRoomPage_1 = newBitMap;
					
					for(i = 0; i < MAXPLAYERS; i++)
					{
						if(!PlayerInGame(i))
						{
							continue;
						}
						delay(1);
						ExecuteClientScript(S_SET_SPAWN_PAGE_1, i, inSpawnRoomPage_1);	
					}
				}	
			}
			else
			{
				if(newBitMap != inSpawnRoomPage_2)
				{
					inSpawnRoomPage_2 = newBitMap;
					for(i = 0; i < MAXPLAYERS; i++)
					{
						if(!PlayerInGame(i))
						{
							continue;
						}
						delay(1);
						ExecuteClientScript(S_SET_SPAWN_PAGE_2, i, inSpawnRoomPage_2);
					}
				}	
			}
		}
	}
}


SCRIPT S_DRAW_NAMES ENTER CLIENTSIDE
{
	str cvar = strparam (s:"toggle_names");
	ALL_VARS[TRACKING_TYPE][0][0] = GetCVar(cvar);
		
	while (true)
	{
		delay(1);
		if(ALL_VARS[TRACKING_TYPE][0][0] == 0)
		{
			continue;
		}
		
		bool recalculateViewMatrix = true;
		ACS_ExecuteWithResult(S_DRAW_NAMES_PLAYERS, recalculateViewMatrix);
		
		recalculateViewMatrix = false;
		ACS_ExecuteWithResult(S_DRAW_NAMES_ACTORS, recalculateViewMatrix);
	}
}

SCRIPT S_DRAW_NAMES_PLAYERS(int recalculateViewMatrix) CLIENTSIDE
{
	int myNumber = PlayerNumber();
	int myTid = myNumber + 3800;
	
	bool isPlayerInSpawnRoom = ACS_ExecuteWithResult(S_IS_IN_SPAWNROOM, myNumber);	
		
	for(int playerIndex = 0; playerIndex < MAXPLAYERS; playerIndex++)
	{	
		if(!PlayerInGame(playerIndex) || playerIndex == myNumber)
		{
			continue;
		}
		
		if(GetPlayerTeam(playerIndex) != PlayerTeam())
		{
			continue;
		}
		
		bool isTeamMateInSpawnRoom = ACS_ExecuteWithResult(S_IS_IN_SPAWNROOM, playerIndex);
		
		if(isPlayerInSpawnRoom != isTeamMateInSpawnRoom)
		{
			continue;
		}	
		
		int playerTID = playerIndex + 3800;
		int currentHealth = GetActorHealth(playerTID);
		if(currentHealth <= 0)
		{
			continue;
		}
		
		bool isSuccess = ACS_ExecuteWithResult(S_PROJECTION, recalculateViewMatrix, playerTID);
		if(!isSuccess)
		{
			continue;
		}
		recalculateViewMatrix = false; //that's how we recalculate it once per frame

		SetHudSize(0, 0, false);
		str playerName = strparam (n:playerIndex + 1);
		
		int screenX = ALL_VARS[RESULT_SCREEN_X][0][0];
		int screenY = ALL_VARS[RESULT_SCREEN_Y][0][0];
		int distance = ALL_VARS[RESULT_DISTANCE][0][0];
		
		SetFont("SMALLFONT");
		HudMessage(s:playerName, s:" \cj[", i:distance,  s:"]"; HUDMSG_PLAIN, 9000 + playerIndex, CR_WHITE, screenX, screenY, 1873);
		
		if(distance < 15)
		{
			int spawnHealth = GetActorSpawnHealth(playerTID);
			HudMessage(s:"Health: ", d:currentHealth, s:"/", d:spawnHealth; HUDMSG_PLAIN, 9100 + playerIndex, CR_WHITE, screenX, screenY + 0.015, 1873);	
		}
	}
}

SCRIPT S_DRAW_NAMES_ACTORS(int recalculateViewMatrix) CLIENTSIDE
{
	int pTeam = PlayerTeam();
		
	for(int i = 0; i < 100; i++)
	{	
		int TID = ALL_VARS[SPOTTED_ACTOR_CLIENT][i][0];
		
		bool isPlayer = TID >= 3800 && TID < 3800 + MAXPLAYERS;
		bool isSuccess = false;
		str actorName;
		if(isPlayer && GetPlayerTeam(TID - 3800) != pTeam)
		{
			int currentHealth = GetActorHealth(TID);
			if(currentHealth > 0)
			{
				isSuccess = ACS_ExecuteWithResult(S_PROJECTION, recalculateViewMatrix, TID);
				if(!isSuccess)
				{
					continue;
				}
		
				actorName = GetActorClass(TID);
				SetFont("SMALLFONT");
				
				HudMessage(s:"Enemy: ", s:actorName, s:" \cj[", i:ALL_VARS[RESULT_DISTANCE][0][0],  s:"]"; HUDMSG_PLAIN, 9000 + MAXPLAYERS + i, CR_DARKRED, 
				ALL_VARS[RESULT_SCREEN_X][0][0], ALL_VARS[RESULT_SCREEN_Y][0][0], 1873);
			}	
		}
		else 
		{
			int actorTeam = GetActorTeam(TID);
			if(actorTeam == -1)
			{
				continue;
			}	
			
			if(actorTeam != pTeam)
			{
				isSuccess = ACS_ExecuteWithResult(S_PROJECTION, recalculateViewMatrix, TID);
				if(!isSuccess)
				{
					continue;
				}
		
				actorName = GetActorName(TID);
				SetFont("SMALLFONT");
				HudMessage(s:"Enemy: ", s:actorName, s:" \cj[", i:ALL_VARS[RESULT_DISTANCE][0][0],  s:"]"; HUDMSG_PLAIN, 9000 + MAXPLAYERS + i, CR_DARKRED, 
				ALL_VARS[RESULT_SCREEN_X][0][0], ALL_VARS[RESULT_SCREEN_Y][0][0], 1873);
			}
			
		}
	}
}


SCRIPT S_IS_IN_SPAWNROOM (int myNumber) CLIENTSIDE
{
    int isPlayerInSpawnRoom;
	if(myNumber < 32)
	{   
		isPlayerInSpawnRoom = (ALL_VARS[SPAWN_ROOM_1][0][0] >> myNumber) & 1;
	}
	else
	{
		isPlayerInSpawnRoom = (ALL_VARS[SPAWN_ROOM_2][0][0] >> (myNumber - 32)) & 1;
	}

    SetResultValue(isPlayerInSpawnRoom);
}


//performes cross multiplication VECTOR_A_3x1 and VECTOR_B_3x1. puts result in VECTOR_C_3x1
SCRIPT S_CROSS (void) CLIENTSIDE
{
	ALL_VARS[VECTOR_C_3x1][0][0] = 
	FixedMul(ALL_VARS[VECTOR_B_3x1][1][0], ALL_VARS[VECTOR_A_3x1][2][0]) - 
	FixedMul(ALL_VARS[VECTOR_A_3x1][1][0], ALL_VARS[VECTOR_B_3x1][2][0]);
	
	ALL_VARS[VECTOR_C_3x1][1][0] = 
	FixedMul(ALL_VARS[VECTOR_A_3x1][0][0], ALL_VARS[VECTOR_B_3x1][2][0]) - 
	FixedMul(ALL_VARS[VECTOR_B_3x1][0][0], ALL_VARS[VECTOR_A_3x1][2][0]);
	
	ALL_VARS[VECTOR_C_3x1][2][0] = 
	FixedMul(ALL_VARS[VECTOR_B_3x1][0][0], ALL_VARS[VECTOR_A_3x1][1][0]) - 
	FixedMul(ALL_VARS[VECTOR_A_3x1][0][0], ALL_VARS[VECTOR_B_3x1][1][0]);
}

//normalizes VECTOR_C_3x1.  puts result in VECTOR_C_3x1
SCRIPT S_NORMALIZE (void) CLIENTSIDE
{
	int magnitude = FixedSqrt(
	FixedMul(ALL_VARS[VECTOR_C_3x1][0][0], ALL_VARS[VECTOR_C_3x1][0][0]) +
	FixedMul(ALL_VARS[VECTOR_C_3x1][1][0], ALL_VARS[VECTOR_C_3x1][1][0]) +
	FixedMul(ALL_VARS[VECTOR_C_3x1][2][0], ALL_VARS[VECTOR_C_3x1][2][0]));
	
	//normalize
	ALL_VARS[VECTOR_C_3x1][0][0] = FixedDiv(ALL_VARS[VECTOR_C_3x1][0][0], magnitude);
	ALL_VARS[VECTOR_C_3x1][1][0] = FixedDiv(ALL_VARS[VECTOR_C_3x1][1][0], magnitude);
	ALL_VARS[VECTOR_C_3x1][2][0] = FixedDiv(ALL_VARS[VECTOR_C_3x1][2][0], magnitude);
}


SCRIPT S_PROJECTION(int recalculateViewMatrix, int targetTID) CLIENTSIDE
{
	int myNumber = PlayerNumber();
	int playerTid = CheckPlayerCamera(myNumber);
	if(playerTid == -1)
	{
        SetResultValue(0);
		terminate;
	}	
	
	int verticalOffset = 0.0;
	
		
	int camX = GetActorX(playerTid);
	int camY = GetActorY(playerTid);
	int camZ = GetActorZ(playerTid) + GetActorViewHeight(playerTid);

	int targetX = GetActorX(targetTID);
	int targetY = GetActorY(targetTID);
	int targetZ = GetActorZ(targetTID) + verticalOffset + GetActorProperty(targetTID, APROP_Height);

	int dx = targetX - camX;
	int dy = targetY - camY;
	int dz = targetZ - camZ;
		
	int dxInt = dx >> 16;
	int dyInt = dy >> 16;
	int dzInt = dz >> 16;	
	int distance = Sqrt(dxInt * dxInt + dyInt * dyInt + dzInt * dzInt) / 100;
	ALL_VARS[RESULT_DISTANCE][0][0] = distance;
		
	int trackingType = ALL_VARS[TRACKING_TYPE][0][0];
	if((trackingType == 1 && trackingType > 50) || (trackingType == 2 && trackingType > 100))
	{
        SetResultValue(0);
		terminate;
	}

	if(recalculateViewMatrix)
	{
		int capAngle = GetActorAngle(playerTid);
		int camPitch = GetActorPitch(playerTid);

		//camera forward vector
		int fx = FixedMul(cos(capAngle),cos(camPitch));
		int fy = FixedMul(sin(capAngle),cos(camPitch));
		int fz = cos(0.25 + camPitch);

		//camera forward
		ALL_VARS[VECTOR_A_3x1][0][0] = fx;
		ALL_VARS[VECTOR_A_3x1][1][0] = fy;
		ALL_VARS[VECTOR_A_3x1][2][0] = fz;


		//world up vector
		ALL_VARS[VECTOR_B_3x1][0][0] = 0;
		ALL_VARS[VECTOR_B_3x1][1][0] = 0;
		ALL_VARS[VECTOR_B_3x1][2][0] = 1.0;
		
		//CROSS CAMERA FORWARD AND WORLD UP
		ACS_ExecuteWithResult(S_CROSS);
		ACS_ExecuteWithResult(S_NORMALIZE);
		
		//camera right vector
		int rx = -ALL_VARS[VECTOR_C_3x1][0][0];
		int ry = -ALL_VARS[VECTOR_C_3x1][1][0];
		int rz = -ALL_VARS[VECTOR_C_3x1][2][0];

		ALL_VARS[VECTOR_B_3x1][0][0] = rx;
		ALL_VARS[VECTOR_B_3x1][1][0] = ry;
		ALL_VARS[VECTOR_B_3x1][2][0] = rz;

		//CROSS CAMERA FORWARD AND CAMERA RIGHT
		ACS_ExecuteWithResult(S_CROSS);

		//camera up vector
		int ux = ALL_VARS[VECTOR_C_3x1][0][0];
		int uy = ALL_VARS[VECTOR_C_3x1][1][0];
		int uz = ALL_VARS[VECTOR_C_3x1][2][0];

		//SET UP WORLD TO CAMERA VIEW MATRIX
		ALL_VARS[VIEW_MATRIX_4x4][0][0] = rx;
		ALL_VARS[VIEW_MATRIX_4x4][1][0] = ux;
		ALL_VARS[VIEW_MATRIX_4x4][2][0] = fx;
		ALL_VARS[VIEW_MATRIX_4x4][3][0] = 0.0;

		ALL_VARS[VIEW_MATRIX_4x4][0][1] = rz;
		ALL_VARS[VIEW_MATRIX_4x4][1][1] = uz;
		ALL_VARS[VIEW_MATRIX_4x4][2][1] = fz;
		ALL_VARS[VIEW_MATRIX_4x4][3][1] = 0.0;

		ALL_VARS[VIEW_MATRIX_4x4][0][2] = ry;
		ALL_VARS[VIEW_MATRIX_4x4][1][2] = uy;
		ALL_VARS[VIEW_MATRIX_4x4][2][2] = fy;
		ALL_VARS[VIEW_MATRIX_4x4][3][2] = 0.0;

		ALL_VARS[VIEW_MATRIX_4x4][0][3] = 0.0;
		ALL_VARS[VIEW_MATRIX_4x4][1][3] = 0.0;
		ALL_VARS[VIEW_MATRIX_4x4][2][3] = 0.0;
		ALL_VARS[VIEW_MATRIX_4x4][3][3] = 1.0;
	}

	int position4x1[4][1];
	int view_position4x1[4][1];
	
	position4x1[0][0] = dx;
	position4x1[1][0] = dz;
	position4x1[2][0] = dy;
	position4x1[3][0] = 1.0;

	//MATRIX MULTIPLICATION START
	int matrix_m = 4;
	int matrix_n = 4;
	int matrix_p = 1;
	
	for (int i = 0; i < matrix_m; i++)
	{
		for (int j = 0; j < matrix_p; j++)
		{
			view_position4x1[i][j] = 0;
			for (int k = 0; k < matrix_n; k++)
			{
				view_position4x1[i][j] += FixedMul(ALL_VARS[VIEW_MATRIX_4x4][i][k], position4x1[k][j]);
			}
		}
	}
	//MATRIX MULTIPLICATION END

	int viewY = view_position4x1[0][0];
	int viewX = view_position4x1[2][0];
	int viewZ = view_position4x1[1][0];
		
	//PROJECT CAMERA VIEW TO SCREEN START
	//let's assume height and width of the screen is 2.
	// top view of camera projection.  BC represen right half of the screen
	// A - is a virtual point behind the screen.
	// B - middle point of the screen. Exact matches player camera position
	// C - right border of the screen.
	// AB = 1
	// BC = tan(BAC) * AB
	//     B       C
	//      _______
	//     |      /
	//     |     /
	//     |    /
	//     |   /
	//     |  /
	//     | /
	//     |/ - half of fov angle between AB and AC
	//     A -virtual point behind the screen

	//if target is behind
	if(viewX <= 0)
	{
        SetResultValue(0);
		terminate;
	}

	int AB = 1.0;
	
	
	bool recalculateFovConstants = false;
	int fovRatio = FixedDiv(GetPlayerInfo(myNumber, PLAYERINFO_FOV), GetPlayerInfo(myNumber, PLAYERINFO_DESIREDFOV));
	if(fovRatio != ALL_VARS[PREV_FOV_RATIO][0][0])
	{
		ALL_VARS[PREV_FOV_RATIO][0][0] = fovRatio;
		recalculateFovConstants = true;
	}

	if(recalculateFovConstants)
	{
		int BAC_H = FixedMul(0.147, fovRatio);
		int sin_BAC_H = sin(BAC_H);
		int cos_BAC_H = cos(BAC_H);
		int tan_BAC_H = FixedDiv(sin_BAC_H, cos_BAC_H);
		ALL_VARS[PROJECTION_BC_H][0][0] = FixedMul(tan_BAC_H, AB); //horizontal half screen size


		int BAC_V = FixedMul(0.0897, fovRatio);
		int sin_BAC_V = sin(BAC_V);
		int cos_BAC_V = cos(BAC_V);
		int tan_BAC_V = FixedDiv(sin_BAC_V, cos_BAC_V);
		ALL_VARS[PROJECTION_BC_V][0][0] = FixedMul(tan_BAC_V, AB); //vertical half screen size
	}

	int projectedScreenX = viewY;
	int projectedScreenY = viewZ;

	int projectedRatio = FixedDiv(projectedScreenY, projectedScreenX); // y = projY/ProjX * X

	int borderX;
	int borderY;

	if(projectedScreenX <= 0)
	{
		borderX = -ALL_VARS[PROJECTION_BC_H][0][0];
	}
	else
	{
		borderX = ALL_VARS[PROJECTION_BC_H][0][0];
	}
	borderY = FixedMul(projectedRatio, borderX);

	if(borderY > ALL_VARS[PROJECTION_BC_V][0][0] || borderY < -ALL_VARS[PROJECTION_BC_V][0][0])
	{
		if(borderY > 0)
		{
			borderY = ALL_VARS[PROJECTION_BC_V][0][0];
		}
		else
		{
			borderY = -ALL_VARS[PROJECTION_BC_V][0][0];
		}
		borderX = FixedDiv(borderY, projectedRatio);
	}

	int projectedScreenMaxDistance = VectorLength(borderX, borderY);

	int projectedDistance = VectorLength(viewY, viewZ);
	int projectedAngleTan = FixedDiv(projectedDistance, viewX);
	int projectedScreenDistance = FixedMul(projectedAngleTan, AB);

	if(projectedScreenDistance > projectedScreenMaxDistance)
	{
		projectedScreenDistance = projectedScreenMaxDistance;
	}

	int borderPoinNormalX = FixedDiv(borderX, projectedScreenMaxDistance);
	int borderPoinNormalY = FixedDiv(borderY, projectedScreenMaxDistance);


	borderPoinNormalX = FixedDiv(borderPoinNormalX, ALL_VARS[PROJECTION_BC_H][0][0]);
	borderPoinNormalY = FixedDiv(borderPoinNormalY, ALL_VARS[PROJECTION_BC_V][0][0]);

	int screenX = FixedMul(borderPoinNormalX, projectedScreenDistance);
	int screenY = FixedMul(borderPoinNormalY, projectedScreenDistance);

	screenX = FixedDiv(screenX + 1.0, 2.0);
	screenY = 1.0 - FixedDiv(screenY + 1.0, 2.0);
	
	ALL_VARS[RESULT_SCREEN_X][0][0] = screenX;
	ALL_VARS[RESULT_SCREEN_Y][0][0] = screenY;
	
}
