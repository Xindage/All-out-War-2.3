// VARIABLES
int ALL_VARS[20][100][4];

#define VIEW_MATRIX_4x4 0 //float array[4][4]
#define VECTOR_A_3x1 1 //float array[4]
#define VECTOR_B_3x1 2 //float array[4]
#define VECTOR_C_3x1 3 //float array[4]
#define PREV_FOV_RATIO 4 //float
#define RESULT_SCREEN_X 5 //float
#define RESULT_SCREEN_Y 6 //float
#define PROJECTION_BC_H 7 //float
#define PROJECTION_BC_V 8 //float
#define SPAWN_ROOM_1 9 //bitmap
#define SPAWN_ROOM_2 10 //bitmap

#define RESULT_DISTANCE 11 //int
#define TRACKING_TYPE 12 //int 0 - disabled, 1 - 50 units, 2 - 100 units, 3 - any distance
#define SPOTTED_ACTOR 13 // int array[SPOT_MAX_ITEMS_COUNT]
#define SPOTTED_TIME_CLIENT 14 // int array[SPOT_MAX_ITEMS_COUNT]
#define SPOTTED_ACTOR_CLIENT 15// int array[SPOT_MAX_ITEMS_COUNT]

// SCRIPTS
#define S_IS_IN_SPAWNROOM 1010
#define S_CROSS 1011
#define S_NORMALIZE 1012
#define S_PROJECTION 1013
#define S_SWITCH_TRACKING_TYPE 1014
#define S_SET_SPAWN_PAGE_1 1015
#define S_SET_SPAWN_PAGE_2 1016
#define S_SPWAN_ROOM_CHECK 1017
#define S_SPOT_ACTOR 1018
#define S_SPOT_ACTOR_CLIENT 1019
#define S_DRAW_NAMES 1020
#define S_SPOT_ACTOR_AND_NOTIFY 1021
#define S_SPOT_TIMEOUT_CHECK_CLIENTSIDE 1022
#define S_DRAW_NAMES_PLAYERS 1024
#define S_DRAW_NAMES_ACTORS 1025
#define S_PIC_RANDOM_TID 1026
#define S_DRAW_DEBUG 1027

//CONST
#define SPOT_DURATION_TIC 350 // int  10 seconds
#define SPOT_MAX_ITEMS_COUNT 50 // 

function str GetActorName(int tid)
{
	str actorName = GetActorClass(tid);
	if(actorName == "TimedC4ArmedBlue" || actorName == "TimedC4Armed")
	{
		return strparam(s:"C4");
	}
	
	if(actorName == "NuclearStrikeBeaconArmed")
	{
		return strparam(s:"Nuke");
	}
	if(actorName == "IonCannonBeaconArmed")
	{
		return strparam(s:"Ion");
	}
	
	if(actorName == "Utility_GunTurretRed" || actorName == "Utility_GunTurretBlue")
	{
		return strparam(s:"Gun T.");
	}
	
	if(actorName == "Utility_ChemTurretRed" || actorName == "Utility_ChemTurretBlue")
	{
		return strparam(s:"Chem T.");
	}
	
	if(actorName == "Utility_FlameTurretRed" || actorName == "Utility_FlameTurretBlue")
	{
		return strparam(s:"Flame T.");
	}
	
	if(actorName == "Utility_PrecisionTurretRed" || actorName == "Utility_PrecisionTurretBlue")
	{
		return strparam(s:"Precision T.");
	}
	
	if(actorName == "Utility_ArtilleryTurretRed" || actorName == "Utility_ArtilleryTurretBlue")
	{
		return strparam(s:"Art T.");
	}
	
	if(actorName == "Utility_RepairGunTurretRed" || actorName == "Utility_RepairGunTurretBlue")
	{
		return strparam(s:"Rep T.");
	}
	
	if(actorName == "Utility_KlaxonRed" || actorName == "Utility_KlaxonBlue")
	{
		return strparam(s:"Klaxon T.");
	}
	
	if(actorName == "Utility_MiniRavenRed" || actorName == "Utility_MiniRavenBlue")
	{
		return strparam(s:"MiniRaven");
	}
	
	if(actorName == "TeleporterNodeRed" || actorName == "TeleporterNodeBlue")
	{
		return strparam(s:"Teleport");
	}
	
	return strparam(s:"None");
}

function str GetActorTeam(int tid)
{
	str actorName = GetActorClass(tid);
	
	if(actorName == "TimedC4ArmedBlue" ||
		actorName == "IonCannonBeaconArmed" ||
		actorName == "Utility_GunTurretBlue" ||
		actorName == "Utility_ChemTurretBlue" ||
		actorName == "Utility_FlameTurretBlue" ||
		actorName == "Utility_PrecisionTurretBlue" ||
		actorName == "Utility_ArtilleryTurretBlue" ||
		actorName == "Utility_RepairGunTurretBlue" ||
		actorName == "Utility_KlaxonBlue" ||
		actorName == "Utility_MiniRavenBlue" ||
		actorName == "TeleporterNodeBlue")
	{
		return 0;
	}
	else if(actorName == "TimedC4Armed" ||
		actorName == "NuclearStrikeBeaconArmed" ||
		actorName == "Utility_GunTurretRed" ||
		actorName == "Utility_ChemTurretRed" ||
		actorName == "Utility_FlameTurretRed" ||
		actorName == "Utility_PrecisionTurretRed" ||
		actorName == "Utility_ArtilleryTurretRed" ||
		actorName == "Utility_RepairGunTurretRed" ||
		actorName == "Utility_KlaxonRed" ||
		actorName == "Utility_MiniRavenRed" ||
		actorName == "TeleporterNodeRed")
	{
		return 1;
	}
	return -1;
}


SCRIPT S_PIC_RANDOM_TID (void)
{
	int activator = ActivatorTID();
	if(activator == 0)
	{
		Thing_ChangeTID(0, UniqueTID(3800 + MAXPLAYERS));		
	}
}

SCRIPT S_SWITCH_TRACKING_TYPE (void) net CLIENTSIDE
{	
	ALL_VARS[TRACKING_TYPE][0][0]++;
	if(ALL_VARS[TRACKING_TYPE][0][0] > 3)
	{
		ALL_VARS[TRACKING_TYPE][0][0] = 0;
	}
	
	SetFont("BIGFONT");
	switch(ALL_VARS[TRACKING_TYPE][0][0])
	{
		case 0:
		HudMessage(s:"Player names are Off"; HUDMSG_PLAIN, 9400, CR_WHITE, 0.5, 0.2, 2.0);
		break;
		
		case 1:
		HudMessage(s:"Player names are On for distance 50"; HUDMSG_PLAIN, 9400, CR_WHITE, 0.5, 0.2, 3.0);
		break;
		
		case 2:
		HudMessage(s:"Player names are On for distance 100"; HUDMSG_PLAIN, 9400, CR_WHITE, 0.5, 0.2, 3.0);
		break;
		
		case 3:
		HudMessage(s:"Player names are On for any distance"; HUDMSG_PLAIN, 9400, CR_WHITE, 0.5, 0.2, 3.0);
		break;
		
		default:
		HudMessage(s:"Track type is not supported: ", i:ALL_VARS[TRACKING_TYPE][0][0]; HUDMSG_PLAIN, 9400, CR_WHITE, 0.5, 0.2, 3.0);
		break;
	}
		
	
	str cvar = strparam (s:"toggle_names");
	SetCVar(cvar, ALL_VARS[TRACKING_TYPE][0][0]);
}

SCRIPT S_SET_SPAWN_PAGE_1(int spawnRoomBitMap) CLIENTSIDE
{
	ALL_VARS[SPAWN_ROOM_1][0][0] = spawnRoomBitMap;
}
SCRIPT S_SET_SPAWN_PAGE_2(int spawnRoomBitMap) CLIENTSIDE
{
	ALL_VARS[SPAWN_ROOM_2][0][0] = spawnRoomBitMap;
}


SCRIPT S_SPOT_ACTOR_CLIENT(int sp_tid) CLIENTSIDE
{
	bool found = false;
	for(int i = 0; i < SPOT_MAX_ITEMS_COUNT; i++)
	{
		if(ALL_VARS[SPOTTED_ACTOR_CLIENT][i][0] == sp_tid)
		{
			ALL_VARS[SPOTTED_TIME_CLIENT][i][0] = timer();		
			found = true;
			break;
		}
	}
	
	if(!found)
	{
		for(i = 0; i < SPOT_MAX_ITEMS_COUNT; i++)
		{
			if(ALL_VARS[SPOTTED_ACTOR_CLIENT][i][0] == 0)
			{
				ALL_VARS[SPOTTED_ACTOR_CLIENT][i][0] = sp_tid;
				ALL_VARS[SPOTTED_TIME_CLIENT][i][0] = timer();
				break;
			}
		}	
	}
}

SCRIPT S_SPOT_ACTOR (void) NET //trys to spot player at sight
{	
	int originalTid = ActivatorTID();
	int capAngle = GetActorAngle(originalTid);
	int camPitch = GetActorPitch(originalTid);	
	LineAttack (0, capAngle, camPitch, 0, "HitscanPuff", "None", 2048.0);
}


SCRIPT S_SPOT_TIMEOUT_CHECK_CLIENTSIDE ENTER CLIENTSIDE
{
	while(true)
	{
		delay(1);
		
		for(int i = 0; i < SPOT_MAX_ITEMS_COUNT; i++)
		{
			int TID = ALL_VARS[SPOTTED_ACTOR_CLIENT][i][0];
			if(TID == 0)
			{
				continue;
			}
			
			bool needToUnspot = false;
			bool isPlayer = TID >= 3800 && TID < 3800 + MAXPLAYERS;
			
			if(isPlayer)
			{
				int playerN = TID - 3800;
				int inGame = PlayerInGame(playerN);
				if(!inGame)
				{
					needToUnspot = true;
				}
			}
			else // turret, c4, nuke/ion
			{
				bool isUsed = IsTIDUsed(TID);
				if(!isUsed)
				{
					needToUnspot = true;	
				}
			}
			
			//actor is present now check the timeout
			if(!needToUnspot)
			{
				int spotTime = ALL_VARS[SPOTTED_TIME_CLIENT][i][0];
				needToUnspot = (timer() - spotTime) > SPOT_DURATION_TIC;
			}
			
			
			if(needToUnspot)
			{
				ALL_VARS[SPOTTED_ACTOR_CLIENT][i][0] = 0;
			}
		}
	}
}

SCRIPT S_SPOT_ACTOR_AND_NOTIFY (void)
{
	int playerTID = GetActorProperty(0, APROP_TargetTID);
	int targetTID = GetActorProperty(0, APROP_TRACERTID);
	
	if(targetTID == 0)
	{
		terminate;
	}
	
	int playerIndex = playerTID - 3800;
	int pTeam = GetPlayerTeam(playerIndex);
	
	str playerName = strparam(n:playerIndex + 1);
	
	/*str team = strparam(s:"red");
	if(pTeam == 0)
	{
		team = strparam(s:"blue");
	}
	str logT = strparam(s:"========== server: player", s:playerName, s:" of team ", s:team);*/
	
	int targetTeam = -1;
	
	bool isTargetPlayer = targetTID >= 3800 && targetTID < 3800 + MAXPLAYERS;
	if(isTargetPlayer)
	{
		int taregtIndex = targetTID - 3800;	
		targetTeam = GetPlayerTeam(taregtIndex);
		if(targetTeam == -1)
		{
			terminate;
		}
	
		/*str tName = strparam(n:taregtIndex + 1);
		
		str tTeam = strparam(s:"red");
		if(targetTeam == 0)
		{
			tTeam = strparam(s:"blue");
		}
		logT = strparam(s:logT, s:" spot player ", s:tName, s:" of team ", s:tTeam);*/
	}
	else
	{
		targetTeam = GetActorTeam(targetTID);
		str actorName = GetActorName(targetTID);
		if(targetTeam == -1)
		{
			terminate;
		}
		
		/*str aTeam = strparam(s:"red");
		if(targetTeam == 0)
		{
			aTeam = strparam(s:"blue");
		}
		logT = strparam(s:logT, s:" spot actor ", s:actorName, s:" of team ", s:aTeam);*/
	}
	
	if(pTeam != targetTeam)
	{		
		for(int i = 0; i < MAXPLAYERS; i++)
		{
			if(PlayerInGame(i) && GetPlayerTeam(i) == pTeam)
			{
				ExecuteClientScript(S_SPOT_ACTOR_CLIENT, i, targetTID);
				delay(1);
			}
		}
	}
	
	//printBold(s:logT);
}


/*script 4444 ENTER
{
	delay(35);
	
	Credits[PlayerNumber()] = 15000;
	SetActorInventory (3800 + PlayerNumber(), "Credit", 15000);
}*/

//tracks whether players are in spawnroom or not
SCRIPT S_SPWAN_ROOM_CHECK OPEN 
{
	//there are 32 bits in integer. each bit is a flag for whether player is in spawn room for player numbers from 0 to 31
	// one integer value covers 32 players
	int pageSize = 32; 
	
	int inSpawnRoomPage_1 = 0; //first 32 players
	int inSpawnRoomPage_2 = 0; //last 32 players
	
	while (true)
	{
		delay(1);
		
		for(int page = 0; page < 2; page++)
		{
			int pageStart = page * pageSize; 
			int pageEnd = (page + 1) * pageSize;
			
			int newBitMap = 0;
			for(int i = pageStart; i < pageEnd; i++) // i is a player index and also a bit position
			{
				int tid = i + 3800;
				int inSpawnRoom = CheckActorInventory(tid, "IsInSpawnRoom");
				if(inSpawnRoom)
				{
					newBitMap |= 1 << (i - pageStart);
				}
				else
				{
					newBitMap &= ~(1 << (i - pageStart));
				}
			}
			
			if(page == 0)
			{
				if(newBitMap != inSpawnRoomPage_1)
				{
					inSpawnRoomPage_1 = newBitMap;
					
					for(i = 0; i < MAXPLAYERS; i++)
					{
						if(!PlayerInGame(i))
						{
							continue;
						}
						delay(1);
						ExecuteClientScript(S_SET_SPAWN_PAGE_1, i, inSpawnRoomPage_1);	
					}
				}	
			}
			else
			{
				if(newBitMap != inSpawnRoomPage_2)
				{
					inSpawnRoomPage_2 = newBitMap;
					for(i = 0; i < MAXPLAYERS; i++)
					{
						if(!PlayerInGame(i))
						{
							continue;
						}
						delay(1);
						ExecuteClientScript(S_SET_SPAWN_PAGE_2, i, inSpawnRoomPage_2);
					}
				}	
			}
		}
	}
}

/*SCRIPT S_DRAW_DEBUG ENTER CLIENTSIDE
{
	while(true)
	{
		delay(1);
		
		for(int i = 0; i < SPOT_MAX_ITEMS_COUNT; i ++)
		{
			int targetTID = ALL_VARS[SPOTTED_ACTOR_CLIENT][i][0];
			int time = ALL_VARS[SPOTTED_TIME_CLIENT][i][0];
			
			str message = strparam(s:"i: ", i:i, s:" TID: ", i:targetTID);
			bool isPlayer = targetTID >= 3800 && targetTID < 3800 + MAXPLAYERS;
			int targetTeam = -1;
			str targetName = strparam(s:"name none");
			
			if(isPlayer)
			{
				int targetIndex = targetTID - 3800;
				targetName = strparam(n:targetIndex + 1);
				message = strparam(s:message, s:"; ", s:"player name: ", s:targetName);	
				targetTeam = GetPlayerTeam(targetIndex);
			}
			else
			{
				str className = GetActorClass(targetTID);
				targetName = GetActorName(targetTID);
				
				message = strparam(s:message, s:"; ", s:"actor class: ", s: className);	
				message = strparam(s:message, s:"; ", s:"actor name: ", s:"", s:targetName);	
				
				targetTeam = GetActorTeam(targetTID);
			}
			
			if(targetTeam == 1)
			{
				message = strparam(s:message, s:"; ", s:"team: RED");		
			}
			else if(targetTeam == 0)
			{
				message = strparam(s:message, s:"; ", s:"team: BLUE");		
			}
			else
			{
				message = strparam(s:message, s:"; ", s:"team: NONE: ", i:targetTeam);
			}
			
			int timeLeft = timer() - time;
			if(timeLeft > SPOT_DURATION_TIC)
			{
				message = strparam(s:message, s:"; time: out");
			}
			else
			{
				message = strparam(s:message, s:"; time: ", i:timeLeft);	
			}
			
			HudMessage(s:message; HUDMSG_PLAIN, 9600 + i, CR_WHITE, 0.7, 0.1 + FixedMul(0.035, i <<16), 0.5);
		}
	}
}*/


/*SCRIPT S_DRAW_DEBUG ENTER
{
	delay(70);
	
	Credits[PlayerNumber()] = 15000;
	SetActorInventory (3800 + PlayerNumber(), "Credit", 15000);
	
	while(true)
	{
		delay(1);
		
		int pn = PlayerNumber();
		SetActivatorToTarget(0);
		int targetTID = ActivatorTID();
		
		str message = strparam(s:"TID: ", i:targetTID);
		bool isPlayer = targetTID >= 3800 && targetTID < 3800 + MAXPLAYERS;
		int targetTeam = -1;
		str targetName = strparam(s:"name none");
		
		if(isPlayer)
		{
			int targetIndex = targetTID - 3800;
			targetName = strparam(n:targetIndex + 1);
			message = strparam(s:message, s:"; ", s:"player name: ", s:targetName);	
			targetTeam = GetPlayerTeam(targetIndex);
		}
		else
		{
			str className = GetActorClass(targetTID);
			targetName = GetActorName(targetTID);
			
			message = strparam(s:message, s:"; ", s:"actor class: ", s: className);	
			message = strparam(s:message, s:"; ", s:"actor name: ", s:"", s:targetName);	
			
			targetTeam = GetActorTeam(targetIndex);
		}
		
		if(targetTeam == 1)
		{
			message = strparam(s:message, s:"; ", s:"team: RED");		
		}
		else if(targetTeam == 0)
		{
			message = strparam(s:message, s:"; ", s:"team: BLUE");		
		}
		else
		{
			message = strparam(s:message, s:"; ", s:"team: NONE: ", i:targetTeam);
		}
		
		SetActivatorToPlayer(pn);
		HudMessage(s:message; HUDMSG_PLAIN, 9990, CR_WHITE, 0.1, 0.05, 0.5);
	}
}*/


SCRIPT S_DRAW_NAMES ENTER CLIENTSIDE
{
	str cvar = strparam (s:"toggle_names");
	ALL_VARS[TRACKING_TYPE][0][0] = GetCVar(cvar);
		
	while (true)
	{
		delay(1);
		if(ALL_VARS[TRACKING_TYPE][0][0] == 0)
		{
			continue;
		}
		
		ACS_ExecuteWithResult(S_DRAW_NAMES_PLAYERS);
		ACS_ExecuteWithResult(S_DRAW_NAMES_ACTORS);
	}
}

SCRIPT S_DRAW_NAMES_PLAYERS(void) CLIENTSIDE
{
	int myNumber = PlayerNumber();
	int myTid = myNumber + 3800;
	bool recalculateViewMatrix = true;
	
	bool isPlayerInSpawnRoom = ACS_ExecuteWithResult(S_IS_IN_SPAWNROOM, myNumber);	
		
	for(int playerIndex = 0; playerIndex < MAXPLAYERS; playerIndex++)
	{	
		if(!PlayerInGame(playerIndex) || playerIndex == myNumber)
		{
			continue;
		}
		
		if(GetPlayerTeam(playerIndex) != PlayerTeam())
		{
			continue;
		}
		
		bool isTeamMateInSpawnRoom = ACS_ExecuteWithResult(S_IS_IN_SPAWNROOM, playerIndex);
		
		if(isPlayerInSpawnRoom != isTeamMateInSpawnRoom)
		{
			continue;
		}	
		
		int playerTID = playerIndex + 3800;
		int currentHealth = GetActorHealth(playerTID);
		if(currentHealth <= 0)
		{
			continue;
		}
		
		bool isSuccess = ACS_ExecuteWithResult(S_PROJECTION, recalculateViewMatrix, playerTID);
		if(!isSuccess)
		{
			continue;
		}
		recalculateViewMatrix = false; //that's how we recalculate it once per frame

		SetHudSize(0, 0, false);
		str playerName = strparam (n:playerIndex + 1);
		
		int screenX = ALL_VARS[RESULT_SCREEN_X][0][0];
		int screenY = ALL_VARS[RESULT_SCREEN_Y][0][0];
		int distance = ALL_VARS[RESULT_DISTANCE][0][0];
		
		SetFont("SMALLFONT");
		HudMessage(s:playerName, s:" \cj[", i:distance,  s:"]"; HUDMSG_PLAIN, 9000 + playerIndex, CR_WHITE, screenX, screenY, 1873);
		
		if(distance < 10)
		{
			int spawnHealth = GetActorSpawnHealth(playerTID);
			HudMessage(s:"Health: ", d:currentHealth, s:"/", d:spawnHealth; HUDMSG_PLAIN, 9100 + playerIndex, CR_WHITE, screenX, screenY + 0.015, 1873);	
		}
	}
}

SCRIPT S_DRAW_NAMES_ACTORS(void) CLIENTSIDE
{
	int pTeam = PlayerTeam();
	bool recalculateViewMatrix = true;
		
	for(int i = 0; i < SPOT_MAX_ITEMS_COUNT; i++)
	{	
		int TID = ALL_VARS[SPOTTED_ACTOR_CLIENT][i][0];
		//str debugMessage = strParam(s:"index: ", i:i, s:"; TID: ", i:TID);
		
		
		bool isPlayer = TID >= 3800 && TID < 3800 + MAXPLAYERS;
		bool isSuccess = false;
		str actorName;
		int targetTeam = -1;
		
		if(isPlayer)
		{
			int targetIndex = TID - 3800;
			targetTeam = GetPlayerTeam(TID - 3800);
			
			/*debugMessage = strParam(s:debugMessage, s:"; player: ", n:targetIndex + 1);	
			if(targetTeam == 1)
			{
				debugMessage = strParam(s:debugMessage, s:"; team: RED");	
			}
			else if(targetTeam == 0)
			{
				debugMessage = strParam(s:debugMessage, s:"; team: BLUE");	
			}
			else
			{
				debugMessage = strParam(s:debugMessage, s:"; team NONE: ", i:targetTeam);	
			}*/
			
			if(targetTeam != pTeam && targetTeam != -1)
			{
				int currentHealth = GetActorHealth(TID);
				//debugMessage = strParam(s:debugMessage, s:"; HP: ", i:currentHealth);	
				
				if(currentHealth > 0)
				{
					isSuccess = ACS_ExecuteWithResult(S_PROJECTION, recalculateViewMatrix, TID);
					if(isSuccess)
					{
						recalculateViewMatrix = false;
						//debugMessage = strParam(s:debugMessage, s:"; Projected!");
						
						actorName = GetActorClass(TID);
						SetFont("SMALLFONT");
						
						HudMessage(s:"Enemy: ", s:" \cj[", i:ALL_VARS[RESULT_DISTANCE][0][0],  s:"]"; 
						HUDMSG_PLAIN, 9000 + MAXPLAYERS + i, 
						CR_DARKRED, ALL_VARS[RESULT_SCREEN_X][0][0], ALL_VARS[RESULT_SCREEN_Y][0][0], 1873);	
						
						HudMessage(s:actorName; HUDMSG_PLAIN, 9000 + MAXPLAYERS + i, 
						CR_DARKRED, ALL_VARS[RESULT_SCREEN_X][0][0], ALL_VARS[RESULT_SCREEN_Y][0][0] + 0.015, 1873);	
					}
					{
						//debugMessage = strParam(s:debugMessage, s:"; Projection failed: ", i:isSuccess);
					}
				}	
			}
		}
		else 
		{
			actorName = GetActorName(TID);
			targetTeam = GetActorTeam(TID);
			
			/*debugMessage = strParam(s:debugMessage, s:"; actor: ", s:actorName);
			if(targetTeam == 1)
			{
				debugMessage = strParam(s:debugMessage, s:"; team: RED");	
			}
			else if(targetTeam == 0)
			{
				debugMessage = strParam(s:debugMessage, s:"; team: BLUE");	
			}
			else
			{
				debugMessage = strParam(s:debugMessage, s:"; team NONE: ", i:targetTeam);	
			}*/
			
			if(targetTeam != pTeam && targetTeam != -1)
			{
				isSuccess = ACS_ExecuteWithResult(S_PROJECTION, recalculateViewMatrix, TID);
				if(isSuccess)
				{	
					recalculateViewMatrix = false;
					//debugMessage = strParam(s:debugMessage, s:"; Projected!");				
					
					SetFont("SMALLFONT");
					HudMessage(s:"Enemy: ", s:actorName, s:" \cj[", i:ALL_VARS[RESULT_DISTANCE][0][0],  s:"]"; HUDMSG_PLAIN, 9000 + MAXPLAYERS + i, CR_DARKRED, 
					ALL_VARS[RESULT_SCREEN_X][0][0], ALL_VARS[RESULT_SCREEN_Y][0][0], 1873);
				}
				else
				{
					//debugMessage = strParam(s:debugMessage, s:"; Projection failed: ", i:isSuccess);
				}
			}
		}
		
		//HudMessage(s:debugMessage; HUDMSG_PLAIN, 9400 + i, CR_WHITE, 0.3, 0.1 + FixedMul(0.05, i <<16), 0.5);
	}
}


SCRIPT S_IS_IN_SPAWNROOM (int myNumber) CLIENTSIDE
{
    int isPlayerInSpawnRoom;
	if(myNumber < 32)
	{   
		isPlayerInSpawnRoom = (ALL_VARS[SPAWN_ROOM_1][0][0] >> myNumber) & 1;
	}
	else
	{
		isPlayerInSpawnRoom = (ALL_VARS[SPAWN_ROOM_2][0][0] >> (myNumber - 32)) & 1;
	}

    SetResultValue(isPlayerInSpawnRoom);
}


//performes cross multiplication VECTOR_A_3x1 and VECTOR_B_3x1. puts result in VECTOR_C_3x1
SCRIPT S_CROSS (void) CLIENTSIDE
{
	ALL_VARS[VECTOR_C_3x1][0][0] = 
	FixedMul(ALL_VARS[VECTOR_B_3x1][1][0], ALL_VARS[VECTOR_A_3x1][2][0]) - 
	FixedMul(ALL_VARS[VECTOR_A_3x1][1][0], ALL_VARS[VECTOR_B_3x1][2][0]);
	
	ALL_VARS[VECTOR_C_3x1][1][0] = 
	FixedMul(ALL_VARS[VECTOR_A_3x1][0][0], ALL_VARS[VECTOR_B_3x1][2][0]) - 
	FixedMul(ALL_VARS[VECTOR_B_3x1][0][0], ALL_VARS[VECTOR_A_3x1][2][0]);
	
	ALL_VARS[VECTOR_C_3x1][2][0] = 
	FixedMul(ALL_VARS[VECTOR_B_3x1][0][0], ALL_VARS[VECTOR_A_3x1][1][0]) - 
	FixedMul(ALL_VARS[VECTOR_A_3x1][0][0], ALL_VARS[VECTOR_B_3x1][1][0]);
}

//normalizes VECTOR_C_3x1.  puts result in VECTOR_C_3x1
SCRIPT S_NORMALIZE (void) CLIENTSIDE
{
	int magnitude = FixedSqrt(
	FixedMul(ALL_VARS[VECTOR_C_3x1][0][0], ALL_VARS[VECTOR_C_3x1][0][0]) +
	FixedMul(ALL_VARS[VECTOR_C_3x1][1][0], ALL_VARS[VECTOR_C_3x1][1][0]) +
	FixedMul(ALL_VARS[VECTOR_C_3x1][2][0], ALL_VARS[VECTOR_C_3x1][2][0]));
	
	//normalize
	ALL_VARS[VECTOR_C_3x1][0][0] = FixedDiv(ALL_VARS[VECTOR_C_3x1][0][0], magnitude);
	ALL_VARS[VECTOR_C_3x1][1][0] = FixedDiv(ALL_VARS[VECTOR_C_3x1][1][0], magnitude);
	ALL_VARS[VECTOR_C_3x1][2][0] = FixedDiv(ALL_VARS[VECTOR_C_3x1][2][0], magnitude);
}


SCRIPT S_PROJECTION(int recalculateViewMatrix, int targetTID) CLIENTSIDE
{	
	int myNumber = PlayerNumber();
	int playerTid = CheckPlayerCamera(myNumber);
	if(playerTid == -1)
	{
        SetResultValue(-1);
		terminate;
	}	
	
	int verticalOffset = 0.0;
	
		
	int camX = GetActorX(playerTid);
	int camY = GetActorY(playerTid);
	int camZ = GetActorZ(playerTid) + GetActorViewHeight(playerTid);

	int targetX = GetActorX(targetTID);
	int targetY = GetActorY(targetTID);
	int targetZ = GetActorZ(targetTID) + verticalOffset + GetActorProperty(targetTID, APROP_Height);

	int dx = targetX - camX;
	int dy = targetY - camY;
	int dz = targetZ - camZ;
		
	int dxInt = dx >> 16;
	int dyInt = dy >> 16;
	int dzInt = dz >> 16;	
	int distance = Sqrt(dxInt * dxInt + dyInt * dyInt + dzInt * dzInt) / 100;
	ALL_VARS[RESULT_DISTANCE][0][0] = distance;
		
	int trackingType = ALL_VARS[TRACKING_TYPE][0][0];
	if((trackingType == 1 && trackingType > 50) || (trackingType == 2 && trackingType > 100))
	{
        SetResultValue(-2);
		terminate;
	}

	if(recalculateViewMatrix)
	{
		int capAngle = GetActorAngle(playerTid);
		int camPitch = GetActorPitch(playerTid);

		//camera forward vector
		int fx = FixedMul(cos(capAngle),cos(camPitch));
		int fy = FixedMul(sin(capAngle),cos(camPitch));
		int fz = cos(0.25 + camPitch);

		//camera forward
		ALL_VARS[VECTOR_A_3x1][0][0] = fx;
		ALL_VARS[VECTOR_A_3x1][1][0] = fy;
		ALL_VARS[VECTOR_A_3x1][2][0] = fz;


		//world up vector
		ALL_VARS[VECTOR_B_3x1][0][0] = 0;
		ALL_VARS[VECTOR_B_3x1][1][0] = 0;
		ALL_VARS[VECTOR_B_3x1][2][0] = 1.0;
		
		//CROSS CAMERA FORWARD AND WORLD UP
		ACS_ExecuteWithResult(S_CROSS);
		ACS_ExecuteWithResult(S_NORMALIZE);
		
		//camera right vector
		int rx = -ALL_VARS[VECTOR_C_3x1][0][0];
		int ry = -ALL_VARS[VECTOR_C_3x1][1][0];
		int rz = -ALL_VARS[VECTOR_C_3x1][2][0];

		ALL_VARS[VECTOR_B_3x1][0][0] = rx;
		ALL_VARS[VECTOR_B_3x1][1][0] = ry;
		ALL_VARS[VECTOR_B_3x1][2][0] = rz;

		//CROSS CAMERA FORWARD AND CAMERA RIGHT
		ACS_ExecuteWithResult(S_CROSS);

		//camera up vector
		int ux = ALL_VARS[VECTOR_C_3x1][0][0];
		int uy = ALL_VARS[VECTOR_C_3x1][1][0];
		int uz = ALL_VARS[VECTOR_C_3x1][2][0];

		//SET UP WORLD TO CAMERA VIEW MATRIX
		ALL_VARS[VIEW_MATRIX_4x4][0][0] = rx;
		ALL_VARS[VIEW_MATRIX_4x4][1][0] = ux;
		ALL_VARS[VIEW_MATRIX_4x4][2][0] = fx;
		ALL_VARS[VIEW_MATRIX_4x4][3][0] = 0.0;

		ALL_VARS[VIEW_MATRIX_4x4][0][1] = rz;
		ALL_VARS[VIEW_MATRIX_4x4][1][1] = uz;
		ALL_VARS[VIEW_MATRIX_4x4][2][1] = fz;
		ALL_VARS[VIEW_MATRIX_4x4][3][1] = 0.0;

		ALL_VARS[VIEW_MATRIX_4x4][0][2] = ry;
		ALL_VARS[VIEW_MATRIX_4x4][1][2] = uy;
		ALL_VARS[VIEW_MATRIX_4x4][2][2] = fy;
		ALL_VARS[VIEW_MATRIX_4x4][3][2] = 0.0;

		ALL_VARS[VIEW_MATRIX_4x4][0][3] = 0.0;
		ALL_VARS[VIEW_MATRIX_4x4][1][3] = 0.0;
		ALL_VARS[VIEW_MATRIX_4x4][2][3] = 0.0;
		ALL_VARS[VIEW_MATRIX_4x4][3][3] = 1.0;
	}

	int position4x1[4][1];
	int view_position4x1[4][1];
	
	position4x1[0][0] = dx;
	position4x1[1][0] = dz;
	position4x1[2][0] = dy;
	position4x1[3][0] = 1.0;

	//MATRIX MULTIPLICATION START
	int matrix_m = 4;
	int matrix_n = 4;
	int matrix_p = 1;
	
	for (int i = 0; i < matrix_m; i++)
	{
		for (int j = 0; j < matrix_p; j++)
		{
			view_position4x1[i][j] = 0;
			for (int k = 0; k < matrix_n; k++)
			{
				view_position4x1[i][j] += FixedMul(ALL_VARS[VIEW_MATRIX_4x4][i][k], position4x1[k][j]);
			}
		}
	}
	//MATRIX MULTIPLICATION END

	int viewY = view_position4x1[0][0];
	int viewX = view_position4x1[2][0];
	int viewZ = view_position4x1[1][0];
		
	//PROJECT CAMERA VIEW TO SCREEN START
	//let's assume height and width of the screen is 2.
	// top view of camera projection.  BC represen right half of the screen
	// A - is a virtual point behind the screen.
	// B - middle point of the screen. Exact matches player camera position
	// C - right border of the screen.
	// AB = 1
	// BC = tan(BAC) * AB
	//     B       C
	//      _______
	//     |      /
	//     |     /
	//     |    /
	//     |   /
	//     |  /
	//     | /
	//     |/ - half of fov angle between AB and AC
	//     A -virtual point behind the screen

	//if target is behind
	if(viewX <= 0)
	{
        SetResultValue(-3);
		terminate;
	}

	int AB = 1.0;
	
	
	bool recalculateFovConstants = false;
	int fovRatio = FixedDiv(GetPlayerInfo(myNumber, PLAYERINFO_FOV), GetPlayerInfo(myNumber, PLAYERINFO_DESIREDFOV));
	if(fovRatio != ALL_VARS[PREV_FOV_RATIO][0][0])
	{
		ALL_VARS[PREV_FOV_RATIO][0][0] = fovRatio;
		recalculateFovConstants = true;
	}

	if(recalculateFovConstants)
	{
		int BAC_H = FixedMul(0.147, fovRatio);
		int sin_BAC_H = sin(BAC_H);
		int cos_BAC_H = cos(BAC_H);
		int tan_BAC_H = FixedDiv(sin_BAC_H, cos_BAC_H);
		ALL_VARS[PROJECTION_BC_H][0][0] = FixedMul(tan_BAC_H, AB); //horizontal half screen size


		int BAC_V = FixedMul(0.0897, fovRatio);
		int sin_BAC_V = sin(BAC_V);
		int cos_BAC_V = cos(BAC_V);
		int tan_BAC_V = FixedDiv(sin_BAC_V, cos_BAC_V);
		ALL_VARS[PROJECTION_BC_V][0][0] = FixedMul(tan_BAC_V, AB); //vertical half screen size
	}

	int projectedScreenX = viewY;
	int projectedScreenY = viewZ;

	int projectedRatio = FixedDiv(projectedScreenY, projectedScreenX); // y = projY/ProjX * X

	int borderX;
	int borderY;

	if(projectedScreenX <= 0)
	{
		borderX = -ALL_VARS[PROJECTION_BC_H][0][0];
	}
	else
	{
		borderX = ALL_VARS[PROJECTION_BC_H][0][0];
	}
	borderY = FixedMul(projectedRatio, borderX);

	if(borderY > ALL_VARS[PROJECTION_BC_V][0][0] || borderY < -ALL_VARS[PROJECTION_BC_V][0][0])
	{
		if(borderY > 0)
		{
			borderY = ALL_VARS[PROJECTION_BC_V][0][0];
		}
		else
		{
			borderY = -ALL_VARS[PROJECTION_BC_V][0][0];
		}
		borderX = FixedDiv(borderY, projectedRatio);
	}

	int projectedScreenMaxDistance = VectorLength(borderX, borderY);

	int projectedDistance = VectorLength(viewY, viewZ);
	int projectedAngleTan = FixedDiv(projectedDistance, viewX);
	int projectedScreenDistance = FixedMul(projectedAngleTan, AB);

	if(projectedScreenDistance > projectedScreenMaxDistance)
	{
		projectedScreenDistance = projectedScreenMaxDistance;
	}

	int borderPoinNormalX = FixedDiv(borderX, projectedScreenMaxDistance);
	int borderPoinNormalY = FixedDiv(borderY, projectedScreenMaxDistance);


	borderPoinNormalX = FixedDiv(borderPoinNormalX, ALL_VARS[PROJECTION_BC_H][0][0]);
	borderPoinNormalY = FixedDiv(borderPoinNormalY, ALL_VARS[PROJECTION_BC_V][0][0]);

	int screenX = FixedMul(borderPoinNormalX, projectedScreenDistance);
	int screenY = FixedMul(borderPoinNormalY, projectedScreenDistance);

	screenX = FixedDiv(screenX + 1.0, 2.0);
	screenY = 1.0 - FixedDiv(screenY + 1.0, 2.0);
	
	ALL_VARS[RESULT_SCREEN_X][0][0] = screenX;
	ALL_VARS[RESULT_SCREEN_Y][0][0] = screenY;
	
}
