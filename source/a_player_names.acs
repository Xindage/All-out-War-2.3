
bool isTrackingEnabled = true;

SCRIPT 1008 (void) net CLIENTSIDE
{	
	isTrackingEnabled = !isTrackingEnabled;
	str cvar = strparam (s:"toggle_names");
	SetCVar(cvar, isTrackingEnabled);
}


SCRIPT 1007 ENTER net CLIENTSIDE
{
	str cvar = strparam (s:"toggle_names");
	isTrackingEnabled = GetCVar(cvar);
	
	int position4x1[4][1];
	int view_position4x1[4][1];
	int view_matrix4x4[4][4];

	int a_3x1[3][1];
	int b_3x1[3][1];
	int c_3x1[3][1];

	int screenX; //from 0 to 1
	int screenY; //from 0 to 1

	int dx;
	int dy;
	int dz;

	int camX;
	int camY;
	int camZ;

	int BC_H;
	int BC_V;


	int prevFovRatio = 1.0;
		
	while (true)
	{
		bool recalculateFovConstants = true;
		
		for(int tick = 0; tick < 35; tick++)
		{
			delay(1);
			
			if(!isTrackingEnabled)
			{
			continue;
			}
			
			int myNumber = PlayerNumber();
			
			int fovRatio = FixedDiv(GetPlayerInfo(myNumber, PLAYERINFO_FOV), GetPlayerInfo(myNumber, PLAYERINFO_DESIREDFOV));
			
			if(fovRatio != prevFovRatio)
			{
				prevFovRatio = fovRatio;
				recalculateFovConstants = true;
			}
			
			int myTid = myNumber + 3800;
				
			bool recalculateViewMatrix = true;
			
			
			for(int playerIndex = 0; playerIndex < MAXPLAYERS; playerIndex++)
			{
				int tid = playerIndex + 3800;
				
				if(!PlayerInGame(playerIndex) || playerIndex == myNumber)
				{
					continue;
				}
				
				if(GetPlayerTeam(playerIndex) == PlayerTeam())
				{
					bool isPlayerInSpawnRoom = CheckInventory("IsInSpawnRoom");
					bool playerHasClass = CheckInventory ("HasClass");
					isPlayerInSpawnRoom = isPlayerInSpawnRoom || !playerHasClass;
					
					SetActivatorToPlayer(playerIndex);
					bool isTeamMateInSpawnRoom = CheckInventory("IsInSpawnRoom");
					bool hasClass = CheckInventory ("HasClass");
					isTeamMateInSpawnRoom = isTeamMateInSpawnRoom || !hasClass;
					SetActivatorToPlayer(myNumber);
					
					
					if(isPlayerInSpawnRoom != isTeamMateInSpawnRoom)
					{
						continue;
					}
					
					
////////////////////GET SCREEN COORDS START
						int verticalOffset = 0.0;


						int targetX = GetActorX(tid);
						int targetY = GetActorY(tid);
						int targetZ = GetActorZ(tid) + verticalOffset + GetActorProperty(tid, APROP_Height);


						if(recalculateViewMatrix)
						{
							int playerTid = CheckPlayerCamera(PlayerNumber());
							if(playerTid == -1)
							{
								continue;
							}

							camX = GetActorX(playerTid);
							camY = GetActorY(playerTid);
							camZ = GetActorZ(playerTid) + GetActorViewHeight(playerTid);
							int capAngle = GetActorAngle(playerTid);
							int camPitch = GetActorPitch(playerTid);

							//camera forward vector
							int fx = FixedMul(cos(capAngle),cos(camPitch));
							int fy = FixedMul(sin(capAngle),cos(camPitch));
							int fz = cos(0.25 + camPitch);

							//camera forward
							a_3x1[0][0] = fx;
							a_3x1[1][0] = fy;
							a_3x1[2][0] = fz;


							//world up vector
							b_3x1[0][0] = 0;
							b_3x1[1][0] = 0;
							b_3x1[2][0] = 1.0;

							//CROSS CAMERA FORWARD AND WORLD UP START
								c_3x1[0][0] = FixedMul(b_3x1[1][0], a_3x1[2][0]) - FixedMul(a_3x1[1][0], b_3x1[2][0]);
								c_3x1[1][0] = FixedMul(a_3x1[0][0], b_3x1[2][0]) - FixedMul(b_3x1[0][0], a_3x1[2][0]);
								c_3x1[2][0] = FixedMul(b_3x1[0][0], a_3x1[1][0]) - FixedMul(a_3x1[0][0], b_3x1[1][0]);

								int magnitude = FixedSqrt(
								FixedMul(c_3x1[0][0], c_3x1[0][0]) +
								FixedMul(c_3x1[1][0], c_3x1[1][0]) +
								FixedMul(c_3x1[2][0], c_3x1[2][0]));
								
								//normalize
								c_3x1[0][0] = FixedDiv(c_3x1[0][0], magnitude);
								c_3x1[1][0] = FixedDiv(c_3x1[1][0], magnitude);
								c_3x1[2][0] = FixedDiv(c_3x1[2][0], magnitude);
							//CROSS CAMERA FORWARD AND WORLD UP END
							
							//camera right vector
							int rx = -c_3x1[0][0];
							int ry = -c_3x1[1][0];
							int rz = -c_3x1[2][0];

							b_3x1[0][0] = rx;
							b_3x1[1][0] = ry;
							b_3x1[2][0] = rz;

							//CROSS CAMERA FORWARD AND CAMERA RIGHT START
								c_3x1[0][0] = FixedMul(b_3x1[1][0], a_3x1[2][0]) - FixedMul(a_3x1[1][0], b_3x1[2][0]);
								c_3x1[1][0] = FixedMul(a_3x1[0][0], b_3x1[2][0]) - FixedMul(b_3x1[0][0], a_3x1[2][0]);
								c_3x1[2][0] = FixedMul(b_3x1[0][0], a_3x1[1][0]) - FixedMul(a_3x1[0][0], b_3x1[1][0]);
							//CROSS CAMERA FORWARD AND CAMERA RIGHT END

							//camera up vector
							int ux = c_3x1[0][0];
							int uy = c_3x1[1][0];
							int uz = c_3x1[2][0];

							//SET UP WORLD TO CAMERA VIEW MATRIX START
								view_matrix4x4[0][0] = rx;
								view_matrix4x4[1][0] = ux;
								view_matrix4x4[2][0] = fx;
								view_matrix4x4[3][0] = 0.0;

								view_matrix4x4[0][1] = rz;
								view_matrix4x4[1][1] = uz;
								view_matrix4x4[2][1] = fz;
								view_matrix4x4[3][1] = 0.0;

								view_matrix4x4[0][2] = ry;
								view_matrix4x4[1][2] = uy;
								view_matrix4x4[2][2] = fy;
								view_matrix4x4[3][2] = 0.0;

								view_matrix4x4[0][3] = 0.0;
								view_matrix4x4[1][3] = 0.0;
								view_matrix4x4[2][3] = 0.0;
								view_matrix4x4[3][3] = 1.0;
							//SET UP VIEW MATRIX END
						}
						dx = targetX - camX;
						dy = targetY - camY;
						dz = targetZ - camZ;

						position4x1[0][0] = dx;
						position4x1[1][0] = dz;
						position4x1[2][0] = dy;
						position4x1[3][0] = 1.0;

						//MATRIX MULTIPLICATION START
							int matrix_m = 4;
							int matrix_n = 4;
							int matrix_p = 1;
							
							for (int i = 0; i < matrix_m; i++)
							{
								for (int j = 0; j < matrix_p; j++)
								{
									view_position4x1[i][j] = 0;
									for (int k = 0; k < matrix_n; k++)
									{
										view_position4x1[i][j] += FixedMul(view_matrix4x4[i][k], position4x1[k][j]);
									}
								}
							}
						//MATRIX MULTIPLICATION END

						int viewY = view_position4x1[0][0];
						int viewX = view_position4x1[2][0];
						int viewZ = view_position4x1[1][0];
						
						//PROJECT CAMERA VIEW TO SCREEN START
							//let's assume height and width of the screen is 2.
							// top view of camera projection.  BC represen right half of the screen
							// A - is a virtual point behind the screen.
							// B - middle point of the screen. Exact matches player camera position
							// C - right border of the screen.
							// AB = 1
							// BC = tan(BAC) * AB
							//     B       C
							//      _______
							//     |      /
							//     |     /
							//     |    /
							//     |   /
							//     |  /
							//     | /
							//     |/ - half of fov angle between AB and AC
							//     A -virtual point behind the screen

							//if target is backwards, just make it slightly in front - in such case we would observ it on screen side 
							//which hints as is target to the left or to the right
							if(viewX <= 0)
							{
								viewX = 1.0;
							}


							int AB = 1.0;

							if(recalculateFovConstants)
							{
								int BAC_H = FixedMul(0.147, fovRatio);
								int sin_BAC_H = sin(BAC_H);
								int cos_BAC_H = cos(BAC_H);
								int tan_BAC_H = FixedDiv(sin_BAC_H, cos_BAC_H);
								BC_H = FixedMul(tan_BAC_H, AB); //horizontal half screen size


								int BAC_V = FixedMul(0.0897, fovRatio);
								int sin_BAC_V = sin(BAC_V);
								int cos_BAC_V = cos(BAC_V);
								int tan_BAC_V = FixedDiv(sin_BAC_V, cos_BAC_V);
								BC_V = FixedMul(tan_BAC_V, AB); //vertical half screen size
							}

							int projectedScreenX = viewY;
							int projectedScreenY = viewZ;

							int projectedRatio = FixedDiv(projectedScreenY, projectedScreenX); // y = projY/ProjX * X

							int borderX;
							int borderY;

							if(projectedScreenX <= 0)
							{
								borderX = -BC_H;
							}
							else
							{
								borderX = BC_H;
							}
							borderY = FixedMul(projectedRatio, borderX);

							if(borderY > BC_V || borderY < -BC_V)
							{
								if(borderY > 0)
								{
									borderY = BC_V;
								}
								else
								{
									borderY = -BC_V;
								}
								borderX = FixedDiv(borderY, projectedRatio);
							}

							int projectedScreenMaxDistance = VectorLength(borderX, borderY);

							int projectedDistance = VectorLength(viewY, viewZ);
							int projectedAngleTan = FixedDiv(projectedDistance, viewX);
							int projectedScreenDistance = FixedMul(projectedAngleTan, AB);

							if(projectedScreenDistance > projectedScreenMaxDistance)
							{
								projectedScreenDistance = projectedScreenMaxDistance;
							}

							int borderPoinNormalX = FixedDiv(borderX, projectedScreenMaxDistance);
							int borderPoinNormalY = FixedDiv(borderY, projectedScreenMaxDistance);


							borderPoinNormalX =  FixedDiv(borderPoinNormalX, BC_H);
							borderPoinNormalY =  FixedDiv(borderPoinNormalY, BC_V);

							screenX = FixedMul(borderPoinNormalX, projectedScreenDistance);
							screenY = FixedMul(borderPoinNormalY, projectedScreenDistance);

							screenX =  FixedDiv(screenX + 1.0, 2.0);
							screenY =  1.0 - FixedDiv(screenY + 1.0, 2.0);
						//PROJECT CAMERA VIEW TO SCREEN END
////////////////////GET SCREEN COORDS END
					
					
					recalculateViewMatrix = false;
					recalculateFovConstants = false;
					
					int dxInt = dx >> 16;
					int dyInt = dy >> 16;
					int dzInt = dz >> 16;
					int distance = Sqrt(dxInt * dxInt + dyInt * dyInt + dzInt * dzInt) / 100;
	
					SetHudSize(0, 0, false);
					str playerName = strparam (n:playerIndex + 1);
					int currentHealth  = GetActorHealth(tid);
					
					if(screenY - 0.05 > 0 && currentHealth > 0)
					{
						
						HudMessage(s:playerName; HUDMSG_PLAIN, 9000 + playerIndex, CR_WHITE, screenX, screenY, 1873);
						
						if(screenX > 0.47 && screenX < 0.53 && screenY < 0.51 && screenY > 0.45)
						{
							int spawnHealth  = GetActorSpawnHealth(tid);
							
							HudMessage(s:"Health: ", d:currentHealth, s:"/", d:spawnHealth, s:" ", d:distance, s:"m.";
							HUDMSG_PLAIN, 9100 + playerIndex, CR_WHITE, screenX, screenY + 0.015, 1873);	
						}
					}
				}
			}
		}
	}
}
