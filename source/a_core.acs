/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * All Out War 2 core mechanism scripts
 * Credit to VoltlocK for originally creating the engine
 * With modifications by the Omega Team
 *
 * You may use portions of this script in your project as long as you give
 * credit where credit is due. Please don't be lame and just copy-paste any
 * of this and call it your own. Thanks!
 */

// =============================================================================
// GAME INITIALIZATION
// Anything that needs to be done on the SERVER side right at game start should
// go here.
script SC_GAMEINIT OPEN {
	delay (1);
	
	// [Dusk] Network state
	NetState |= NETSTATE_Server;
	
	for (int i = 0; i <= 1; i++) {
		GotRefinery[i] = True;
		GotBarracks[i] = True;
		GotFactory[i] = True;
		GotResearch[i] = True;
		GotRepair[i] = True;
		GotObelisk[i] = True;
	}
	
	intHolder[i_StartingTickets] = GetCVAR ("zeta_tickets");
	
	SetLineSpecial (159, ACS_Execute, 342);
	
	// Seems like the initial speeds for buildings are bogus. Correct them!
	SYNC_UpdateAllBuildings ();
	
	// For some reasons, the class and item arrays can get
	// bogus values. Attempt to fix them.
	//FixFuckedUpArrays ();
	
	// Activate developer mode if the proper cvar is set.
	if (GetCVAR ("zeta_developer")) {
		intHolder[i_DeveloperSafetyLock] = 0x7FFFFFFF;
		ACS_ExecuteAlways (SC_DEVELOPERMODE, 0);
	}
	
	// If we have ticket pool active, set the initial tickets now.
	if (GetCVAR("zeta_ticketpool") || GetCVar ("zeta_ticketmode")) {
		SetTickets (TEAM_Blue, GetCVAR ("zeta_tickets"));
		SetTickets (TEAM_RED, GetCVAR ("zeta_tickets"));
	}
	
	// Map markers
	//SpawnSpotForced ("CrateMapMarker", TID_CRATE, 0, 0);
	SpawnSpotForced ("TiberiumMapMarker", TID_TIBERIUM, 0, 0);
	
	// [Xindage] Some sanity checks and debug info should be done before the cleanup
	// so if the map is missing buildings we can make sure if its intentional.
	// First check if we are offline, this bedug should not be printed online.
	if (netstate == NETSTATE_Offline)
	{
		str pair[2][MAX_BUILDINGS];
		for (int z = 0; z < MAX_BUILDINGS-5; z++)
		{
			// Not Really an issue but multiple ids are not really ideal.
			if (ThingCount (0, MainTIDs[0][z]) >= 2 || ThingCount (0, MainTIDs[1][z]) >= 2)
				{pair[0][z] = " ? Multiple TIDs detected!"; pair[1][z] = "\cn";}
			else if (ThingCount (0, MainTIDs[0][z]) == 1 && ThingCount (0, MainTIDs[1][z]) == 1)
				{pair[0][z] = " Ok!"; pair[1][z] = "\cd";}
			else if (ThingCount (0, MainTIDs[0][z]) == 0 && ThingCount (0, MainTIDs[1][z]) == 1)
				{pair[0][z] = " Error! Missing \caBlue \cuTerminal!"; pair[1][z] = "\ci";}
			else if (ThingCount (0, MainTIDs[0][z]) == 1 && ThingCount (0, MainTIDs[1][z]) == 0)
				{pair[0][z] = " Error! Missing \cgRed \cuTerminal!"; pair[1][z] = "\ci";}
			else {pair[0][z] = " Ok! No terminals found."; pair[1][z] = "\cu";}
		}
		HudMessageBold (
			s:pair[1][0], s:"Barracks:",			s:pair[0][0], s:"\n",
			s:pair[1][1], s:"Refinery:",			s:pair[0][1], s:"\n",
			s:pair[1][2], s:"Research Centre:",		s:pair[0][2], s:"\n",
			s:pair[1][3], s:"War Factory:",			s:pair[0][3], s:"\n",
			s:pair[1][5], s:"Obelisk of Light:",	s:pair[0][5], s:"\n",
			s:pair[1][4], s:"Repair Facility:",		s:pair[0][4];
			HUDMSG_PLAIN, 100, CR_WHITE, 0.4, 0.25, 6.0);
	}

	// [Xindage] Dusk applied a cleanup work when one of the terminals were missing for War Factory
	// Now if any of the terminals for any building is missing, everything else will be cleaned.
	for (int y = 0; y < MAX_BUILDINGS-5; y++)
	{
		switch (y)
		{
			case 0:
				if (ThingCount (0, TID_BARRACKS_BLUE) * ThingCount (0, TID_BARRACKS_RED) == 0)
				{
//					SetMapFlags (MAPF_NoBar);
					GotBarracks[0] = false;
					GotBarracks[1] = false;
					Thing_Remove (TID_BARRACKS_BLUE);
					Thing_Remove (TID_BARRACKS_RED);
					Thing_Remove (TID_BARBTOS_BLUE);
					Thing_Remove (TID_BARBTOS_RED);
				}
				break;
			case 1:
				if (ThingCount (0, TID_REFINERY_BLUE) * ThingCount (0, TID_REFINERY_RED) == 0)
				{
//					SetMapFlags (MAPF_NoRef);
					GotRefinery[0] = false;
					GotRefinery[1] = false;
					Thing_Remove (TID_REFINERY_BLUE);
					Thing_Remove (TID_REFINERY_RED);
					Thing_Remove (TID_REFBTOS_BLUE);
					Thing_Remove (TID_REFBTOS_RED);
				}
				break;
			case 2:
				if (ThingCount (0, TID_RESCENTRE_BLUE) * ThingCount (0, TID_RESCENTRE_RED) == 0)
				{
//					SetMapFlags (MAPF_NoRes);
					GotResearch[0] = false;
					GotResearch[1] = false;
					Thing_Remove (TID_RESCENTRE_BLUE);
					Thing_Remove (TID_RESCENTRE_RED);
					Thing_Remove (TID_RESBTOS_BLUE);
					Thing_Remove (TID_RESBTOS_RED);
				}
				break;
			case 3:
				if (ThingCount (0, TID_FACTORY_BLUE) * ThingCount (0, TID_FACTORY_RED) == 0)
				{
					SetMapFlags (MAPF_NoMechs);
					GotFactory[0] = false;
					GotFactory[1] = false;
					Thing_Remove (TID_FACTORY_BLUE);
					Thing_Remove (TID_FACTORY_RED);
					Thing_Remove (TID_FACBTOS_BLUE);
					Thing_Remove (TID_FACBTOS_RED);
				}
				break;
			case 4:
				if (ThingCount (0, TID_REPAIR_BLUE) * ThingCount (0, TID_REPAIR_RED) == 0)
				{
//					SetMapFlags (MAPF_NoRep);
					GotRepair[0] = false;
					GotRepair[1] = false;
					Thing_Remove (TID_REPAIR_BLUE);
					Thing_Remove (TID_REPAIR_RED);
					Thing_Remove (TID_REPBTOS_BLUE);
					Thing_Remove (TID_REPBTOS_RED);
				}
				break;
			case 5:
				if (ThingCount (0, TID_OBELISK_BLUE) * ThingCount (0, TID_OBELISK_RED) == 0)
				{
//					SetMapFlags (MAPF_NoObe);
					GotObelisk[0] = false;
					GotObelisk[1] = false;
					Thing_Remove (TID_OBELISK_BLUE);
					Thing_Remove (TID_OBELISK_RED);
					Thing_Remove (TID_OBEBTOS_BLUE);
					Thing_Remove (TID_OBEBTOS_RED);
				}
				break;
		}
	}
	
	// Record initial building healths
	for (i = 0; i < MAX_BUILDINGS; i++)
	{
		RecordedBuildingHealths[0][i] = GetActorSpawnHealth (MainTIDs[0][i]);
		RecordedBuildingHealths[1][i] = GetActorSpawnHealth (MainTIDs[1][i]);
	}
	
	// Build various data tables
	InitClasses();
	
	BuildMenuClasses ();
	BuildMenuResearches ();
	BuildMenuMechs ();
	InitParticleFuserData ();
	CR_InitCrateList ();
	
	// If we're offline, set the game to multiplayer emulation
	// for more accurate netgame emulation.
	if (netstate == NETSTATE_Offline)
		ConsoleCommand ("netgame");
}

function void SetConfig (int key, str val) {
	int changed = (Config[key][PEER_SERVER] != val);
	Config[key][PEER_SERVER] = val;
	if (netstate == NETSTATE_Offline) {
		// Syncing is not done in offline mode. Furthermore, we're
		// both the "client" and the "server", so just set the values
		// here.
		Config[key][PEER_CLIENT] = Config[key][PEER_SERVER];
	} else if (changed) {
		// Log (s:name, s:" is now ", d:val);
		
		// The value changed, inform clients about it!
		SYNC_UpdateConfig (key);
	}
}

// Server settings
script SC_SERVERSETTINGS OPEN 
{
	// NOTE: We really need to check every CVAR? why not just set it and be over with it?
	// ==================================
	// DMFLAGS - These are enforced at every map start to prevent wrong behaviours.
	// ==================================
	if (GetCVAR  ("sv_nojump")) 					ConsoleCommand ("sv_nojump 0");
	if (GetCVAR  ("sv_nocrouch"))					ConsoleCommand ("sv_nocrouch 0");
	if (!GetCVAR ("sv_allowjump")) 					ConsoleCommand ("sv_allowjump 1");
	if (!GetCVAR ("sv_allowcrouch"))				ConsoleCommand ("sv_allowcrouch 1");
	if (!GetCVAR ("sv_weapondrop"))					ConsoleCommand ("sv_weapondrop 1");
	if (!GetCVAR ("sv_nodrop"))						ConsoleCommand ("sv_nodrop 1"); // Prevents dropping weapons on-command.
	if (!GetCVAR ("sv_itemrespawn"))				ConsoleCommand ("sv_itemrespawn 1");
	if (!GetCVAR ("compat_limited_airmovement"))	ConsoleCommand ("compat_limited_airmovement 1");
	if (GetCVAR  ("sv_nomedals"))					ConsoleCommand ("sv_nomedals 0");
	if (GetCVAR  ("sv_nomonsters"))					ConsoleCommand ("sv_nomonsters 0");
	if (!GetCVAR ("sv_nofov"))						ConsoleCommand ("sv_nofov 1"); // Eliminate gauss sniping
	if (GetCVAR  ("sv_weaponstay"))					ConsoleCommand ("sv_weaponstay 0");
	if (getcvar  ("sv_aircontrol") == 0)			ConsoleCommand ("sv_aircontrol 0.00390625"); // Make ladders not glitchy.
	if (!intHolder[i_gameover] && GetCVAR ("pointlimit") != 0)
		ConsoleCommand ("pointlimit 0"); // No pointlimit until game is considered over.
		// Its necessary to check if the game is over if round just started?

	// ======================================================================
	// [Dusk] Synchronized configurations!
	SetConfig (CONFIG_ALTEXP, GetCVAR ("zeta_altexp"));
	SetConfig (CONFIG_STARTTICKETS, GetCVAR ("zeta_tickets"));
	SetConfig (CONFIG_MECHS, (!CheckMapFlags (MAPF_NOMECHS) && !GetCVAR ("zeta_nomechs")));
	SetConfig (CONFIG_TOURNAMENTMODE, intHolder[i_TournamentMode]);
	SetConfig (CONFIG_MAXTIMECOPS, GetCVAR ("zeta_maxtimecopsperteam"));
	SetConfig (CONFIG_JUGGERNAUTLIMIT, GetCVAR ("zeta_juggernautlimit"));
	SetConfig (CONFIG_C4DELAY, GetCVAR ("zeta_c4delay"));
	SetConfig (CONFIG_NORADAR, GetCVAR ("zeta_noradar"));
	SetConfig (CONFIG_CREDITCAP, GetCVAR ("zeta_creditcap"));
	
	// [Dusk] {9/6/12} Are these needed in this function? They're updated upon research anyway.
	SetConfig (CONFIG_ADVTURRETS_BLUE, AdvancedTurrets[TEAM_BLUE]);
	SetConfig (CONFIG_ADVTURRETS_RED, AdvancedTurrets[TEAM_RED]);
	SetConfig (CONFIG_MAXTURRETS_BLUE, MaxTurrets[TEAM_BLUE]);
	SetConfig (CONFIG_MAXTURRETS_RED, MaxTurrets[TEAM_RED]);
	
	// [JD] Check to see if we use all the mechs or only the light ones.
	SetConfig(CONFIG_LIGHTMECHS, ThingCountName("CONFIG_LightMechsOnly", 0));
	SetConfig(CONFIG_MAXUTILITYGUY, GetCvar("zeta_maxutilityguy"));

	// 2022/10/11 Xindage - Check if the map uses 3d buildings.
	SetConfig(CONFIG_3DBUILDINGS, ThingCountName("CONFIG_buildingsIs3D", 0));

	delay (35);
	restart;
}

//Setting Player scripts
script SC_PLAYERRESPAWN RESPAWN 
{
	if (StartTime[PlayerNumber()] == 0)
		InitPlayer();
	
	GiveInventory("IsInSpawnRoom", 1);
	if(PlayerTeam() == TEAM_BLUE)
		GiveInventory ("IsBlue",1);
	else if(PlayerTeam() == TEAM_RED)
		GiveInventory ("IsRed",1);
	
	Thing_ChangeTID (0, PlayerNumber()+3800);
	
	if(GetPlayerInfo(PlayerNumber(),PLAYERINFO_GENDER) == 1) {
		SetActorProperty(0,APROP_DeathSound,"female/death");
		GiveInventory("IsFemale",1);
	}
	
	if (!CheckWeapon ("Unarmed"))
		SetWeapon ("Unarmed");
	
	GiveInventory ("Credit", Credits[PlayerNumber()]);
	GiveInventory ("Experience", Experience[PlayerNumber()]);
	
	SetInventory ("IsAdmin", IsAdmin[PlayerNumber()]);
	
	// [Cata] Set player health for consistency.
	ACS_ExecuteAlways(SC_PLAYERCHECKRANK, 0, 0, 0, 0);
	delay(5);
	SetHealth (GetSpawnHealth ());
}

script SC_CL_Respawn RESPAWN CLIENTSIDE {
	// [Dusk] Mark down if we respawned
	if (PlayerNumber() == intHolder[i_consoleplayer])
		intHolder[i_consoledead] = false;
}

script SC_PLAYERENTER ENTER {
	InitPlayer ();
	
	ACS_ExecuteAlways (SC_PLAYERRESPAWN, 0);
	
	// [Dusk] Check team balance now as the player's
	// entrance may have caused surplus in team counts.
	// We need an one-tic delay first, however.
	delay (1);
	CheckTeamBalance ();
}

Script SC_PLAYERDISCONNECT (int gone) DISCONNECT {
	// [Dusk] {11/2/12} Donate all credits to teammates. This
	// has to be done before the block below which resets credits!
	if (!GetCVar ("zeta_nodisconnectdonate")) {
		int team = PlayersTeam[gone];
		int teammates = GetTeamProperty (team, TPROP_NumPlayers);
		if (teammates > 0) {
			int cred = Credits[gone];
			int share = cred / teammates;
			int donater = PlayerNumber();
			for (int i = 0; i < MAXPLAYERS; i++) {
				if (!PlayerInGame (i) || GetPlayerTeam (i) != team)
					continue;
				
				GivePlayerCredits (i, share);
			}
		}
	}
	
	IsAdmin[gone] = false;
	SetPlayerCredits (gone, 0);
	Experience[gone] = 0;
	Surrender[gone] = 0;
	PlasmaCooldown[gone] = 0;
	StartTime[gone] = 0;
	
	Thing_ChangeTID (3800 + gone, 0);
	
	// [Dusk] There is no longer anybody sitting in the team's hanger.
	if (MechGetter[PlayersTeam[gone]] == gone && GettingMech[PlayersTeam[gone]])
		GettingMech[PlayersTeam[gone]] = false;
	
	if (Surrender[Gone]) {
		Surrender[Gone] = false;
		if (PlayersTeam[Gone] == TEAM_RED) {
			IntelMessage (strparam (s:"\cD", d:SurrenderCount (TEAM_RED), s:"\cQ/\cD", d:RedCount(), s:" ",
				s:"\cJof \cARed Team\cJ\n have voted to surrender"), true);
		} else if (PlayersTeam[Gone] == TEAM_BLUE) {
			IntelMessage (strparam (s:"\cD", d:SurrenderCount (TEAM_BLUE), s:"\cQ/\cD", d:BlueCount(), s:" ",
				s:"\cJof \cNBlue Team\cJ\n have voted to surrender"), true);
		}
	}
	else // % of players surrendering could now be higher. Al demands a recount!
		ACS_Execute(751, 0);
	
	// [Dusk] Check team balance now, this disconnect may
	// have unbalanced them.
	CheckTeamBalance ();
}

// =============================================================================
// Client-side end
script SC_CL_PLAYERENTER ENTER CLIENTSIDE {

	if (PlayerNumber() != intHolder[i_consoleplayer])
		terminate;
	
	// START UP MESSAGES
	int y = 0.3;
	
	SetFont ("BIGFONT");
	HudMessage(s:"Welcome to \cFAll Out War 2!";
		HUDMSG_FADEINOUT|HUDMSG_LOG, IntroMsgID, CR_WHITE, 0.5, y, 7.0, 0.5, 1.0);
	y += 0.15;
	
	SetHUDFont ();
	
	// [Cata] No being overwhelmed with messages. It's just ugh.
	/*
	HUDMessage (s:"You are running version ", s:VersionString ();
		HUDMSG_FADEINOUT|HUDMSG_LOG, 0, CR_WHITE, 0.5, y, 7.0, 0.5, 1.0);
	y += SMALLSPACE;
	
	HudMessage (s:"\nSee \cFOptions \cN-> \cFCustomise Controls\c- for keybinds!";
		HUDMSG_FADEINOUT|HUDMSG_LOG, 0, CR_WHITE, 0.5, y, 7.0, 0.5, 1.0);
	y += SMALLSPACE;
	*/
	if (GetConfig (CONFIG_ALTEXP)) {
		HudMessage (s:"This server uses alternate experience mode.\n",
			s:"Rank needs are down to a third\n",
			s:"\cGbut you lose it all when you die!";
			HUDMSG_FADEINOUT|HUDMSG_LOG, 0, CR_GOLD, -0.25, 0.6, 12.0, 0.5, 1.0);
		y += 0.25;
	}
	
	if (VERSION_MINOR > 50 && netstate == NETSTATE_Client) {
		// This is running a beta version
		HudMessage (s:"This is a beta release, bear in mind that\n",
			s:"everything might not be working properly!\n\n",
			s:"If you do experience bugs/glitches be sure to contact Xindage";
			HUDMSG_FADEINOUT|HUDMSG_LOG, IntroMsgID+1, CR_GOLD, 0.5, y, 7.0, 0.5, 1.0);
		y += 0.25;
	}
	
	delay (20);
	
	if (netstate == NETSTATE_Client)
		LocalAmbientSound ("voltlock/welcome", 127);
	
	// =========================================================================
	// [Dusk] We joined the game - refresh the HUD
	if (PlayerNumber () == intHolder[i_consoleplayer]) {
		DisplayStatusHUD ();
		// DrawTeamLogHeader ();
	}
}

// [Dusk] Dummy script, maps call this :/
// [Xindage] Lets comment it out for a while, what could go wrong :3
// script 92 (void) {}

// [Dusk]
script SC_CL_PLAYERDISCONNECT (int gone) DISCONNECT CLIENTSIDE {
	// If we DISCONNECTed, yet this script executed,
	// we became a spectator.
	if (gone == intHolder[i_consoleplayer]) {
		// We're no longer dead
		intHolder[i_consoledead] = false;
		
		// Refresh the HUD to clear out the credits/exp display.
		DisplayStatusHUD ();
		
		// Also clear the menu
		ClearMenu ();
		
		// HACK: For some reason disconnecting causes OPEN CLIENTSIDE scripts
		// to be terminated. Get around this by re-executing affected scripts.
		delay (1);
		ACS_Execute (SC_HUDDaemon, 0);
	}
}

function void InitPlayer (void) {
	SetCredits (GetCVAR ("zeta_startcredits"));
	Experience[PlayerNumber()] = 0;
	Surrender[PlayerNumber()] = False;
	PlayersTeam[PlayerNumber()] = PlayerTeam();
	StartTime[PlayerNumber()] = Timer();
	HasTeleported[PlayerNumber()] = false;
	RepairBonus[PlayerNumber()] = 0;
	MedicBonus[PlayerNumber()] = 0;
	UnawardedDamage[PlayerNumber ()] = 0;
	
	// [Dusk] If we're in developer mode, make him gamemaster.
	if (intHolder[i_Developer]) {
		IsAdmin[PlayerNumber()] = true;
		
		SetFont ("BIGFONT");
		HudMessage(s:"This game is in developer mode. You have gamemaster access.";
			HUDMSG_FADEINOUT, 0, CR_BLUE, 0.5, 0.2, 7.0, 0.5, 1.0);
	}
}

// =============================================================================
// [Dusk] This script checks for the game-over condition and ends the game if so.
script SC_GameOver (int team, int small) {
	SetActivator (-1);
	
	if (CalcBaseLeft (!team))
		terminate;
	
	// No buildings left standing, thus the game is over.
	intHolder[i_gameover] = true;
	Delay (1);
	
	// Give the end-of-game points to the winning team.
	// This ensures that the correct team actually wins.
	int winpoints = GetTeamProperty (!team, TPROP_PointCount) - GetTeamProperty (team, TPROP_PointCount);
	if (winpoints < 0) // Don't let it be negative.
		winpoints = 0;
	
	winpoints += 5;
	
	// Set the pointlimit accordingly. `pointlimit 1` works for now but
	// it could be seen as a bug (there's actually a ticket on the tracker
	// about this at the time of this writing) so I'm dynamically setting the
	// points so that the winning team has just about enough score to reach it.
	int pointlimit = GetTeamProperty (team, TPROP_PointCount) + winpoints;
	ConsoleCommand (strparam (s:"pointlimit ", d:pointlimit));
	
	// Give the final points to the winning team. This line ends the game.
	Team_GivePoints (team, winpoints, false);
}
